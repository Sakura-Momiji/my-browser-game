<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>シミュレーション（統合版）108</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --cell: 52px;
    --grid-border:#333;
    --red:#f88; --red-text:#000;
    --blue:#88f; --blue-text:#fff;
    --abyss:#000;
    --respawn-r:#ffd5df;
    --respawn-b:#d5e9ff;
    --hilite:#ffe97a;
    --conflict:#b682ff;
  }
  body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#fafafa;margin:16px;text-align:center}
  h1{margin:.2rem 0 .6rem}
  #topbar{display:flex;flex-wrap:wrap;gap:.5rem;justify-content:center;align-items:center}
  button{cursor:pointer;border:none;border-radius:10px;padding:.6rem .9rem;background:#4caf50;color:#fff;font-weight:600}
  button.secondary{background:#607d8b}
  button.warn{background:#e91e63}
  button:disabled{opacity:.5;cursor:not-allowed}
  #hud{margin:.6rem auto;display:flex;flex-wrap:wrap;gap:.8rem;justify-content:center;align-items:center}
  #hud .card{background:#fff;border:1px solid #ddd;border-radius:12px;padding:.4rem .8rem;min-width:12ch}
  #whoseWrap{border-radius:10px;padding:.2rem .6rem;color:#000}
  #boardOuter{display:inline-block;padding:10px;border:2px solid var(--grid-border);border-radius:14px;background:#fff;margin-top:12px}
  #boardWrap{position:relative;display:inline-block;margin:0 auto;border-radius:12px;padding:10px;background:#fff}
  #board{display:grid;gap:0}
  .cell{
    width:var(--cell);height:var(--cell);
    border:1px solid #ccc;display:flex;align-items:center;justify-content:center;
    position:relative;font-size:12px;user-select:none
  }
  .label-x{position:absolute;top:-14px;left:2px;font-size:10px;color:#666}
  .label-y{position:absolute;left:-14px;top:2px;font-size:10px;color:#666}
  .abyss{background:var(--abyss) !important}
  .respawn-red{background:var(--respawn-r)}
  .respawn-blue{background:var(--respawn-b)}
  .piece{border-radius:9px;padding:2px 6px;font-weight:700;min-width:calc(var(--cell) - 10px);text-align:center}
  .piece.red{background:var(--red);color:var(--red-text)}
  .piece.blue{background:var(--blue);color:var(--blue-text)}
  .highlight{outline:3px solid var(--hilite);outline-offset:-3px}
  .conflict{box-shadow:inset 0 0 0 9999px color-mix(in srgb, var(--conflict) 35%, transparent)}
  /* 矢印 (SVG) */
  #arrowLayer{position:absolute;inset:10px;pointer-events:none}
  /* 下部情報 */
  #selectionInfo{margin:.6rem auto;min-height:1.6rem;color:#333}
  /* モーダル共通 */
  .modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,.5);align-items:center;justify-content:center;padding:16px;z-index:10}
  .modal.show{display:flex}
  .modal .panel{background:#fff;border-radius:14px;min-width:320px;max-width:92vw;padding:16px;text-align:left;position:relative}
  .modal h2{margin:.2rem 0 .6rem}
  .closeX{position:absolute;right:10px;top:8px;font-weight:800;color:#e91e63;cursor:pointer}
  .row{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap;margin:.3rem 0}
  .row label{min-width:9rem}
  input[type="number"]{width:7rem;padding:.3rem}
  select, input[type="text"]{padding:.3rem}
  .hr{height:1px;background:#eee;margin:.6rem 0}
  /* バトル一覧 */
  #battleList .battleRow{border:1px solid #eee;border-radius:10px;padding:8px;margin:6px 0;background:#fafbfd}
  #battleList .side{display:flex;flex-direction:column;gap:3px;min-width:10rem}
  .flex{display:flex;gap:.6rem;align-items:center;flex-wrap:wrap}
  .grow{flex:1}
  .tag{font-size:11px;border:1px solid #ddd;border-radius:999px;padding:.1rem .5rem;background:#fff}
  .note{font-size:12px;color:#666}
  /* リザルト */
  #resultPanel h1{font-size:28px;margin:.2rem 0 .6rem}
  #resultPanel .stats{line-height:1.9}
</style>
</head>
<body>
  <h1>シミュレーション（統合版）</h1>

  <div id="topbar">
    <button id="btnSettings" class="secondary">設定</button>
    <button id="btnStart">ゲーム開始</button>
    <button id="btnMoveDone" disabled>移動完了</button>
    <button id="btnUndo" class="warn" disabled>やり直し（1フェーズ戻る）</button>
  </div>

  <div id="hud">
    <div class="card">ターン: <span id="turnNow">0</span> / <span id="turnLimit">10</span></div>
    <div class="card">現在: <span id="whoseWrap"><span id="whoseTurn">準備段階</span></span> <span id="phaseTag" class="tag" style="display:none"></span></div>
    <div class="card">赤ライフ: <span id="lifeRed">10</span>　青ライフ: <span id="lifeBlue">10</span></div>
    <div class="card">赤勝利Pt: <span id="vpRed">0</span>　青勝利Pt: <span id="vpBlue">0</span></div>
  </div>

  <div id="boardOuter">
    <div id="boardWrap">
      <svg id="arrowLayer"></svg>
      <div id="board"></div>
    </div>
  </div>

  <div id="selectionInfo"></div>

  <!-- 設定モーダル -->
  <div id="settingsModal" class="modal"><div class="panel">
    <div class="closeX" data-close="settingsModal">×</div>
    <h2>設定</h2>

    <div class="row"><label>テンプレート</label>
      <select id="inpTemplate">
        <option value="none">（選択なし）</option>
        <option value="sampleA">サンプルA</option>
        <option value="sampleB">サンプルB</option>
      </select>
      <button id="btnApplyTemplate" class="secondary">テンプレ適用</button>
    </div>

    <div class="row"><label>盤面の大きさ（N×N）</label><input type="number" id="inpSize" min="3" max="30" value="8"></div>
    <div class="row"><label>ターン数（終了）</label><input type="number" id="inpTurnLimit" min="1" max="200" value="10"></div>
    <div class="row"><label>赤ライフ</label><input type="number" id="inpLifeRed" min="1" max="99" value="10"></div>
    <div class="row"><label>青ライフ</label><input type="number" id="inpLifeBlue" min="1" max="99" value="10"></div>
    <div class="hr"></div>
    <h3>移動距離（コスト上限）</h3>
    <div class="row"><label>ポーン</label><input type="number" id="mvPawn" min="1" max="12" value="3"></div>
    <div class="row"><label>ナイト</label><input type="number" id="mvKnight" min="1" max="12" value="4"></div>
    <div class="row"><label>ビショップ</label><input type="number" id="mvBishop" min="1" max="12" value="5"></div>
    <div class="row"><label>ルーク</label><input type="number" id="mvRook" min="1" max="12" value="6"></div>
    <div class="row"><label>クイーン</label><input type="number" id="mvQueen" min="1" max="12" value="6"></div>
    <div class="row"><label>キング</label><input type="number" id="mvKing" min="1" max="12" value="3"></div>
    <div class="hr"></div>
    <div class="row"><label>デバッグモード</label>
      <select id="inpDebug"><option value="off">OFF</option><option value="on">ON</option></select>
    </div>
    <div class="note">設定を適用すると盤面はリセットされ、フェーズ0（準備）に戻ります。</div>
    <div class="row" style="justify-content:flex-end">
      <button id="btnApplySettings">適用</button>
    </div>
  </div></div>

  <!-- 配置/編集モーダル（フェーズ0のみ） -->
  <div id="placeModal" class="modal"><div class="panel">
    <div class="closeX" data-close="placeModal">×</div>
    <h2 id="placeTitle">配置 / 編集</h2>
    <div class="row">
      <label>種類</label>
      <select id="selKind">
        <option value="piece">コマ</option>
        <option value="gimmick">ギミック</option>
      </select>
    </div>
    <div id="optPiece">
      <div class="row"><label>色</label>
        <select id="selTeam"><option value="red">赤</option><option value="blue">青</option></select>
      </div>
      <div class="row"><label>タイプ</label>
        <select id="selType">
          <option>ポーン</option><option>ナイト</option><option>ビショップ</option><option>ルーク</option><option>クイーン</option><option>キング</option>
        </select>
      </div>
      <div class="row"><label>名前</label><input id="inpName" type="text" placeholder="未入力はタイプ名"></div>
    </div>
    <div id="optGimmick" style="display:none">
      <div class="row"><label>ギミック</label>
        <select id="selGimmick"><option value="abyss">奈落</option><option value="respawn">リスポーンエリア</option></select>
      </div>
      <div class="row" id="rowRespawnColor"><label>色（リスポーン）</label>
        <select id="selRespawnTeam"><option value="red">赤</option><option value="blue">青</option></select>
      </div>
    </div>
    <div class="row" style="justify-content:flex-end;gap:.5rem">
      <button id="btnDelete" class="warn">削除</button>
      <button id="btnPlaceApply">適用</button>
    </div>
  </div></div>

  <!-- バトルモーダル（赤/引分/青） -->
  <div id="battleModal" class="modal"><div class="panel">
    <h2>バトル結果を選択</h2>
    <div id="battleList"></div>
    <div class="row" style="justify-content:space-between;align-items:center">
      <span id="battleWarn" class="note" style="display:none;color:#d32f2f">まだ勝敗が決まっていない試合があります</span>
      <button id="btnBattleConfirm">決定</button>
    </div>
  </div></div>

  <!-- リザルト -->
  <div id="resultModal" class="modal"><div id="resultPanel" class="panel">
    <h1 id="winnerText"></h1>
    <div class="stats">
      <div>経過ターン数: <span id="resTurns"></span></div>
      <div>赤ライフ: <span id="resLifeR"></span>　青ライフ: <span id="resLifeB"></span></div>
      <div>赤勝利Pt: <span id="resVpR"></span>　青勝利Pt: <span id="resVpB"></span></div>
    </div>
    <div class="row" style="justify-content:flex-end;margin-top:.6rem">
      <button onclick="location.reload()">リスタート</button>
    </div>
  </div></div>

<script>
/* =========================
   データ構造
========================= */
const boardEl = document.getElementById('board');
const arrowLayer = document.getElementById('arrowLayer');

const state = {
  size: 8,
  turnLimit: 10,
  life: { red:10, blue:10 },
  debug: false,
  moveCost: { 'ポーン':3,'ナイト':4,'ビショップ':5,'ルーク':6,'クイーン':6,'キング':3 },

  phase: 0,                 // 0=準備, 1=赤, 2=青, 3=赤...
  turn: 0,                  // 両軍完了で+1
  team: 'red',              // 現在の行動側
  vp: { red:0, blue:0 },

  cells: [],                // [y][x] = { terrain:'empty'|'abyss'|'respawn-red'|'respawn-blue', pieces:[pieceId,...] }
  pieces: {},               // id -> {id, team, type, name, x, y, alive:true, moved:false, plan:{x,y,ox,oy}}
  nextId: 1,

  arrows: [],               // {id, from:{x,y}, to:{x,y}}

  history: []               // JSON snapshots（1フェーズ戻る用：スタック）
};

function deepCopy(obj){ return JSON.parse(JSON.stringify(obj)); }
function pushHistory(){
  state.history.push(JSON.stringify({
    size:state.size, turnLimit:state.turnLimit, life:state.life, debug:state.debug, moveCost:state.moveCost,
    phase:state.phase, turn:state.turn, team:state.team, vp:state.vp,
    cells:state.cells, pieces:state.pieces, nextId:state.nextId, arrows:state.arrows
  }));
}
function undoOnePhase(){
  if(!state.history.length) return false;
  const snap = JSON.parse(state.history.pop());
  Object.assign(state, snap);
  renderAll();
  return true;
}

/* =========================
   ユーティリティ
========================= */
function numToCol(n){ let s=""; while(n>=0){ s=String.fromCharCode((n%26)+65)+s; n=Math.floor(n/26)-1;} return s; }
function inBounds(x,y){ return x>=0 && y>=0 && x<state.size && y<state.size; }
function cellAt(x,y){ return state.cells[y][x]; }
function pieceById(id){ return state.pieces[id]; }
function teamOpp(t){ return t==='red'?'blue':'red'; }
function isRespawnTerrain(t){ return t==='respawn-red' || t==='respawn-blue'; }

/* =========================
   盤面生成・描画
========================= */
function resetBoard(size=state.size){
  state.size = size;
  state.cells = Array.from({length:size}, (_,y)=>
    Array.from({length:size}, (_,x)=>({terrain:'empty', pieces:[]})));
  state.pieces = {};
  state.nextId = 1;
  state.arrows = [];
}

function renderBoard(){
  boardEl.innerHTML = '';
  boardEl.style.gridTemplateColumns = `repeat(${state.size}, var(--cell))`;

  const svgW = state.size*parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'));
  arrowLayer.setAttribute('viewBox', `0 0 ${svgW} ${svgW}`);
  arrowLayer.innerHTML = '';
  addArrowMarker();

  for(let y=0;y<state.size;y++){
    for(let x=0;x<state.size;x++){
      const c = document.createElement('div');
      c.className = 'cell';
      c.dataset.x = x; c.dataset.y = y;

      if(y===0){ const lx = document.createElement('div'); lx.className='label-x'; lx.textContent=numToCol(x); c.appendChild(lx); }
      if(x===0){ const ly = document.createElement('div'); ly.className='label-y'; ly.textContent=y+1; c.appendChild(ly); }

      const cell = cellAt(x,y);
      if(cell.terrain==='abyss') c.classList.add('abyss');
      if(cell.terrain==='respawn-red') c.classList.add('respawn-red');
      if(cell.terrain==='respawn-blue') c.classList.add('respawn-blue');

      cell.pieces.forEach(id=>{
        const p = pieceById(id); if(!p || !p.alive) return;
        const chip = document.createElement('div');
        chip.className = `piece ${p.team}`;
        chip.textContent = p.name;
        c.appendChild(chip);
      });

      const teamsHere = new Set(cell.pieces.map(id=>pieceById(id)?.team).filter(Boolean));
      if(teamsHere.size>=2 && !isRespawnTerrain(cell.terrain)) c.classList.add('conflict');

      c.addEventListener('click', ()=>onCellClick(x,y));
      boardEl.appendChild(c);
    }
  }
  drawArrows();
}

function renderHUD(){
  document.getElementById('lifeRed').textContent = state.life.red;
  document.getElementById('lifeBlue').textContent = state.life.blue;
  document.getElementById('vpRed').textContent = state.vp.red;
  document.getElementById('vpBlue').textContent = state.vp.blue;
  document.getElementById('turnLimit').textContent = state.turnLimit;
  document.getElementById('turnNow').textContent = state.turn;

  const phaseTag = document.getElementById('phaseTag');
  if(state.debug){ phaseTag.style.display='inline-block'; phaseTag.textContent = `フェーズ ${state.phase}`; }
  else { phaseTag.style.display='none'; }

  const whoseWrap = document.getElementById('whoseWrap');
  const whoseTurn = document.getElementById('whoseTurn');
  if(state.phase===0){
    whoseTurn.textContent = '準備段階';
    whoseWrap.style.background = 'transparent';
    whoseWrap.style.color = '#000';
  }else{
    const isRed = state.team==='red';
    whoseTurn.textContent = (isRed?'赤':'青') + ' のターン';
    whoseWrap.style.background = isRed ? 'var(--red)' : 'var(--blue)';
    whoseWrap.style.color = isRed ? 'var(--red-text)' : 'var(--blue-text)';
  }

  document.getElementById('btnMoveDone').disabled = (state.phase===0);
  document.getElementById('btnStart').disabled = (state.phase!==0);
  document.getElementById('btnUndo').disabled = (state.history.length===0);
}

function renderAll(){ renderBoard(); renderHUD(); }

/* =========================
   ピース / 配置
========================= */
function placePiece(team,type,name,x,y){
  const id = state.nextId++;
  const p = { id, team, type, name: name||type, x, y, alive:true, moved:false, plan:null };
  state.pieces[id] = p;
  cellAt(x,y).pieces.push(id);
  return p;
}
function removePieceFromCell(id){
  const p = pieceById(id); if(!p) return;
  const arr = cellAt(p.x,p.y).pieces;
  const k = arr.indexOf(id); if(k>=0) arr.splice(k,1);
}
function movePieceTo(id,x,y){
  const p = pieceById(id); if(!p) return;
  removePieceFromCell(id);
  p.x = x; p.y = y;
  cellAt(x,y).pieces.push(id);
}

function findRespawnCell(team){
  for(let y=0;y<state.size;y++) for(let x=0;x<state.size;x++){
    const t = cellAt(x,y).terrain;
    if((team==='red' && t==='respawn-red') || (team==='blue' && t==='respawn-blue')) return {x,y};
  }
  return null;
}

/* =========================
   準備段階：配置/編集モーダル
========================= */
const placeModal = document.getElementById('placeModal');
let selectedCellCoord = null;
let editingExisting = null;

document.querySelectorAll('.closeX').forEach(x=>x.addEventListener('click', e=>{
  const id = e.target.getAttribute('data-close'); document.getElementById(id).classList.remove('show');
}));
document.getElementById('selKind').addEventListener('change', e=>{
  const piece = document.getElementById('optPiece');
  const gim = document.getElementById('optGimmick');
  if(e.target.value==='piece'){ piece.style.display='block'; gim.style.display='none'; }
  else { piece.style.display='none'; gim.style.display='block'; }
});
document.getElementById('selGimmick').addEventListener('change', e=>{
  document.getElementById('rowRespawnColor').style.display = (e.target.value==='respawn')?'flex':'none';
});

function onCellClick(x,y){
  if(state.phase!==0){ onCellClickDuringTurn(x,y); return; }
  selectedCellCoord = {x,y};
  const cell = cellAt(x,y);
  const occupiedPieceId = cell.pieces[0] ?? null;
  editingExisting = null;
  if(occupiedPieceId){
    const p = pieceById(occupiedPieceId);
    document.getElementById('selKind').value='piece';
    document.getElementById('optPiece').style.display='block';
    document.getElementById('optGimmick').style.display='none';
    document.getElementById('selTeam').value = p.team;
    document.getElementById('selType').value = p.type;
    document.getElementById('inpName').value = p.name;
    editingExisting = p.id;
  }else if(cell.terrain!=='empty'){
    document.getElementById('selKind').value='gimmick';
    document.getElementById('optPiece').style.display='none';
    document.getElementById('optGimmick').style.display='block';
    if(cell.terrain==='abyss') document.getElementById('selGimmick').value='abyss';
    if(cell.terrain==='respawn-red'){ document.getElementById('selGimmick').value='respawn'; document.getElementById('selRespawnTeam').value='red';}
    if(cell.terrain==='respawn-blue'){ document.getElementById('selGimmick').value='respawn'; document.getElementById('selRespawnTeam').value='blue';}
    editingExisting = cell.terrain;
  }else{
    document.getElementById('selKind').value='piece';
    document.getElementById('optPiece').style.display='block';
    document.getElementById('optGimmick').style.display='none';
    document.getElementById('inpName').value='';
  }
  document.getElementById('placeTitle').textContent = '配置 / 編集';
  placeModal.classList.add('show');
}

document.getElementById('btnDelete').addEventListener('click', ()=>{
  if(!selectedCellCoord) return;
  const {x,y} = selectedCellCoord;
  const cell = cellAt(x,y);
  if(editingExisting && typeof editingExisting==='number'){
    const id = editingExisting;
    removePieceFromCell(id);
    delete state.pieces[id];
  }else if(editingExisting){
    cell.terrain = 'empty';
  }
  placeModal.classList.remove('show');
  renderAll();
});

document.getElementById('btnPlaceApply').addEventListener('click', ()=>{
  if(!selectedCellCoord) return;
  const {x,y} = selectedCellCoord;
  const cell = cellAt(x,y);

  const kind = document.getElementById('selKind').value;
  if(kind==='piece'){
    if(cell.pieces.length) { const id = cell.pieces[0]; delete state.pieces[id]; cell.pieces = []; }
    const team = document.getElementById('selTeam').value;
    const type = document.getElementById('selType').value;
    const name = document.getElementById('inpName').value.trim() || type;
    placePiece(team, type, name, x, y);
  }else{
    const g = document.getElementById('selGimmick').value;
    if(g==='abyss') cell.terrain='abyss';
    else{
      const t = document.getElementById('selRespawnTeam').value;
      cell.terrain = t==='red' ? 'respawn-red' : 'respawn-blue';
    }
    while(cell.pieces.length){ const id = cell.pieces.pop(); delete state.pieces[id]; }
  }
  placeModal.classList.remove('show');
  renderAll();
});

/* =========================
   ターン開始/移動/仮移動
========================= */
let reachable = new Set(); // "x,y"
let selectedPieceId = null;

function startGame(){
  if(state.phase!==0) return;
  pushHistory(); // 0→1 へ移る前のスナップショット（Undo用）
  state.phase = 1; state.team='red'; state.turn = 1;
  for(const p of Object.values(state.pieces)){ p.moved=false; p.plan=null; }
  state.arrows = [];
  renderAll();
}

function onCellClickDuringTurn(x,y){
  const cell = cellAt(x,y);
  const ownIds = cell.pieces.filter(id=>pieceById(id)?.team===state.team && pieceById(id)?.alive);
  const candidate = ownIds.map(id=>pieceById(id)).find(p=>!p.moved);
  if(candidate){ selectPiece(candidate.id); return; }

  const key = `${x},${y}`;
  if(selectedPieceId && reachable.has(key)){ planMove(selectedPieceId, x, y); return; }

  clearSelection();
}

function selectPiece(id){
  selectedPieceId = id;
  const p = pieceById(id);
  document.getElementById('selectionInfo').textContent = `選択中: ${p.name}（${p.type} / ${p.team==='red'?'赤':'青'}）`;
  computeReachable(id);
  renderBoardHighlights();
}

function clearSelection(){
  selectedPieceId = null;
  reachable.clear();
  document.getElementById('selectionInfo').textContent = '';
  renderBoardHighlights();
}

/* 可動範囲：同一ターンの仮移動先（plan）には入れない。 */
function computeReachable(id){
  reachable.clear();
  const p = pieceById(id); if(!p) return;
  const maxCost = state.moveCost[p.type] ?? 3;

  const plannedSet = new Set(); // "x,y"
  for(const q of Object.values(state.pieces)){
    if(q.alive && q.plan){ plannedSet.add(`${q.plan.x},${q.plan.y}`); }
  }

  const Q = [{x:p.x, y:p.y, cost:0}];
  const seen = new Set([`${p.x},${p.y}`]);

  while(Q.length){
    const cur = Q.shift();
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dx,dy] of dirs){
      const nx = cur.x+dx, ny = cur.y+dy, nc=cur.cost+1;
      const k = `${nx},${ny}`;
      if(!inBounds(nx,ny) || nc>maxCost || seen.has(k)) continue;
      const c = cellAt(nx,ny);
      if(c.terrain==='abyss') continue;

      const alliesHere = c.pieces.map(id=>pieceById(id)).filter(pp=>pp && pp.team===p.team);

      // 味方がすでに居る場所には入れない（リスポーンでも不可）
      if(alliesHere.length) {
        continue;
      }

      // 他コマの仮移動先は不可（敵味方問わず、リスポーンでも不可）
      if(plannedSet.has(k)) {
        continue;
      }

      reachable.add(k);
      seen.add(k);
      Q.push({x:nx,y:ny,cost:nc});
    }
  }
  reachable.delete(`${p.x},${p.y}`);
}

function renderBoardHighlights(){
  renderBoard();
  if(!selectedPieceId) return;
  document.querySelectorAll('#board .cell').forEach(el=>{
    const x=+el.dataset.x, y=+el.dataset.y;
    if(reachable.has(`${x},${y}`)) el.classList.add('highlight');
  });
}

function planMove(id, x, y){
  const p = pieceById(id); if(!p) return;

  // 目的地が他の仮移動先なら拒否（リスポーン地形は許可）
  const dest = cellAt(x,y);
  const isAnyRespawn = isRespawnTerrain(dest.terrain);
  if(!isAnyRespawn){
    for(const q of Object.values(state.pieces)){
      if(q.plan && q.plan.x===x && q.plan.y===y && q.id!==p.id){
        return; // 取り合い禁止
      }
    }
  }

  // 以前のプラン矢印を消す
  if(p.plan){ state.arrows = state.arrows.filter(a=>a.id!==p.id); }

  p.plan = { x, y, ox:p.x, oy:p.y };
  p.moved = false; // これをtrueにすると仮移動の選択しなおしができなくなる。

  // 同色同マスの競合：リスポーン地形なら多重OK、そうでなければ後勝ち優先で先のプランを取消
  if(!isAnyRespawn){
    for(const q of Object.values(state.pieces)){
      if(q.id!==p.id && q.alive && q.team===p.team && q.plan && q.plan.x===x && q.plan.y===y){
        q.plan = null; q.moved=false;
      }
    }
  }

  state.arrows.push({ id:p.id, from:{x:p.x,y:p.y}, to:{x,y} });

  clearSelection();
  renderBoardHighlights();
}


function commitMoves(){
  // 本確定の前に履歴を積む（Undoでこのフェーズに戻れる）
  pushHistory();

  // 仮移動を本移動へ
  for(let y=0;y<state.size;y++) for(let x=0;x<state.size;x++) state.cells[y][x].pieces = [];

  for(const p of Object.values(state.pieces)){
    if(!p.alive) continue;
    if(p.plan){ p.x = p.plan.x; p.y = p.plan.y; }
    state.cells[p.y][p.x].pieces.push(p.id);
  }

  // 敵リスポーン踏み：ダメージ→自軍リスポーンへワープ（ここではバトルを発生させない）
  processEnemyRespawnCaptures();

  // バトル対象セル（リスポーン上は除外）
  const conflicts = collectConflicts();
  renderAll();
  if(conflicts.length){ openBattleModal(conflicts); }
  else { endTurn(); }
}

function processEnemyRespawnCaptures(){
  const warpQueue = [];
  let dmgRed=0, dmgBlue=0;
  for(let y=0;y<state.size;y++) for(let x=0;x<state.size;x++){
    const cell = cellAt(x,y);
    if(cell.terrain==='respawn-red'){
      const blues = cell.pieces.map(id=>pieceById(id)).filter(p=>p && p.team==='blue');
      if(blues.length){ dmgRed += blues.length; blues.forEach(p=>warpQueue.push(p)); }
    }
    if(cell.terrain==='respawn-blue'){
      const reds = cell.pieces.map(id=>pieceById(id)).filter(p=>p && p.team==='red');
      if(reds.length){ dmgBlue += reds.length; reds.forEach(p=>warpQueue.push(p)); }
    }
  }
  if(dmgRed) state.life.red = Math.max(0, state.life.red - dmgRed);
  if(dmgBlue) state.life.blue = Math.max(0, state.life.blue - dmgBlue);

    // 敵陣のリスポーンを踏んだ時のワープ処理
 warpQueue.forEach(p=>{
  removePieceFromCell(p.id);
  // そのチームのすべてのリスポーン地点を取得
  const respawns = findAllRespawnCells(p.team);
  // まだ誰もいない場所を探す
  const empty = respawns.find(c => c.pieces.length === 0);
  if(empty){
    // 空きがあればそこへ移動
    movePieceTo(p.id, empty.x, empty.y);
  }else{
    // 空きがない場合の処理（例：強制死亡）
    p.alive = false;
    // もし「重複でも置く」で良いなら：
    // const sp = respawns[0]; movePieceTo(p.id, sp.x, sp.y);
  }
});
}

function collectConflicts(){
  const list = [];
  for(let y=0;y<state.size;y++) for(let x=0;x<state.size;x++){
    const cell = cellAt(x,y);
    if(isRespawnTerrain(cell.terrain)) continue; // リスポーン上は戦闘しない（ライフ処理優先）
    const reds = cell.pieces.map(id=>pieceById(id)).filter(p=>p && p.team==='red');
    const blues = cell.pieces.map(id=>pieceById(id)).filter(p=>p && p.team==='blue');
    if(reds.length && blues.length){
      list.push({ x,y, red:reds[0], blue:blues[0], result:null });
    }
  }
  return list;
}

/* =========================
   矢印描画
========================= */
function addArrowMarker(){
  const defs = document.createElementNS('http://www.w3.org/2000/svg','defs');
  const marker = document.createElementNS('http://www.w3.org/2000/svg','marker');
  marker.setAttribute('id','arrowhead');
  marker.setAttribute('markerWidth','8'); marker.setAttribute('markerHeight','8');
  marker.setAttribute('refX','6'); marker.setAttribute('refY','3'); marker.setAttribute('orient','auto');
  const path = document.createElementNS('http://www.w3.org/2000/svg','path');
  path.setAttribute('d','M0,0 L6,3 L0,6 z'); path.setAttribute('fill','#444');
  marker.appendChild(path); defs.appendChild(marker); arrowLayer.appendChild(defs);
}
function drawArrows(){
  const cellPx = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'));
  for(const a of state.arrows){
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    const x1 = a.from.x*cellPx + cellPx/2;
    const y1 = a.from.y*cellPx + cellPx/2;
    const x2 = a.to.x*cellPx + cellPx/2;
    const y2 = a.to.y*cellPx + cellPx/2;
    line.setAttribute('x1',x1); line.setAttribute('y1',y1);
    line.setAttribute('x2',x2); line.setAttribute('y2',y2);
    line.setAttribute('stroke','#444'); line.setAttribute('stroke-width','3');
    line.setAttribute('marker-end','url(#arrowhead)');
    arrowLayer.appendChild(line);
  }
}

/* =========================
   バトルモーダル（赤/引分/青）
========================= */
const battleModal = document.getElementById('battleModal');
const battleListEl = document.getElementById('battleList');
const battleWarn = document.getElementById('battleWarn');
let battles = []; // {x,y, red, blue, result}

function openBattleModal(conflicts){
  battles = conflicts;
  battleListEl.innerHTML = '';
  conflicts.forEach((b,idx)=>{
    const row = document.createElement('div');
    row.className = 'battleRow';
    row.innerHTML = `
      <div class="flex" style="justify-content:space-between;gap:12px">
        <div class="side">
          <strong>${b.red.name}</strong>
          <span class="tag">赤 / ${b.red.type}</span>
        </div>
        <div class="grow" style="text-align:center">VS<br><span class="tag">マス ${numToCol(b.x)}-${b.y+1}</span></div>
        <div class="side" style="text-align:right">
          <strong>${b.blue.name}</strong>
          <span class="tag">青 / ${b.blue.type}</span>
        </div>
      </div>
      <div class="flex" style="justify-content:center;margin-top:6px">
        <button data-ans="red">赤の勝ち</button>
        <button data-ans="draw" class="secondary">引き分け</button>
        <button data-ans="blue">青の勝ち</button>
      </div>
    `;
    row.querySelectorAll('button').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        b.result = btn.getAttribute('data-ans');
        row.querySelectorAll('button').forEach(b2=>b2.disabled=false);
        btn.disabled = true;
        battleWarn.style.display='none';
      });
    });
    battleListEl.appendChild(row);
  });
  battleModal.classList.add('show');
}

document.getElementById('btnBattleConfirm').addEventListener('click', ()=>{
  if(battles.some(b=>!b.result)){ battleWarn.style.display='inline'; return; }
  for(const b of battles){
    if(b.result==='red' || b.result==='blue'){
      const winner = (b.result==='red') ? b.red : b.blue;
      const loser  = (b.result==='red') ? b.blue : b.red;
      state.vp[winner.team] += 1;
      if(loser.type==='キング') state.life[loser.team] = Math.max(0, state.life[loser.team]-1);
      const sp = findRespawnCell(loser.team);
      removePieceFromCell(loser.id);
      if(sp) movePieceTo(loser.id, sp.x, sp.y); else loser.alive=false;
    }else{
      for(const side of [b.red,b.blue]){
        const sp = findRespawnCell(side.team);
        removePieceFromCell(side.id);
        if(sp) movePieceTo(side.id, sp.x, sp.y); else side.alive=false;
      }
    }
  }
  battleModal.classList.remove('show');
  endTurn();
});

/* =========================
   ターン終了 / 勝利判定 / リザルト
========================= */
function endTurn(){
  // 次チームへ
  state.phase += 1;
  state.team = (state.team==='red') ? 'blue' : 'red';

  // 赤→青の切替ではターン据え置き、青→赤へ戻る時に+1
  if(state.team==='red') state.turn += 1;

  // 矢印クリア
  state.arrows = [];

  // 各ピースのフラグをリセット
  for(const p of Object.values(state.pieces)){ if(!p.alive) continue; p.moved=false; p.plan=null; }

  // 勝利判定
  const winner = checkWin();
  renderAll();
  if(winner){ showResult(winner); }
}

function checkWin(){
  if(state.life.red<=0 && state.life.blue<=0) return 'draw';
  if(state.life.red<=0) return 'blue';
  if(state.life.blue<=0) return 'red';
  if(state.turn > state.turnLimit){
    if(state.life.red !== state.life.blue) return state.life.red>state.life.blue?'red':'blue';
    if(state.vp.red !== state.vp.blue) return state.vp.red>state.vp.blue?'red':'blue';
    return 'draw';
  }
  return null;
}

function showResult(winner){
  const modal = document.getElementById('resultModal');
  const title = document.getElementById('winnerText');
  title.textContent = winner==='draw' ? '引き分け！' : (winner==='red'?'赤の勝利！':'青の勝利！');
  const isRed = winner==='red';
  document.getElementById('resultPanel').style.background = winner==='draw' ? '#fff' : (isRed?'var(--respawn-r)':'var(--respawn-b)');
  title.style.background = winner==='draw' ? '#eee' : (isRed?'var(--red)':'var(--blue)');
  title.style.color = winner==='draw' ? '#333' : (isRed?'var(--red-text)':'var(--blue-text)');
  document.getElementById('resTurns').textContent = state.turn;
  document.getElementById('resLifeR').textContent = state.life.red;
  document.getElementById('resLifeB').textContent = state.life.blue;
  document.getElementById('resVpR').textContent = state.vp.red;
  document.getElementById('resVpB').textContent = state.vp.blue;
  modal.classList.add('show');
}

/* =========================
   UI: 設定 / 開始 / 移動完了 / Undo / テンプレ
========================= */
document.getElementById('btnSettings').addEventListener('click', ()=>{
  document.getElementById('inpSize').value = state.size;
  document.getElementById('inpTurnLimit').value = state.turnLimit;
  document.getElementById('inpLifeRed').value = state.life.red;
  document.getElementById('inpLifeBlue').value = state.life.blue;
  document.getElementById('mvPawn').value = state.moveCost['ポーン'];
  document.getElementById('mvKnight').value = state.moveCost['ナイト'];
  document.getElementById('mvBishop').value = state.moveCost['ビショップ'];
  document.getElementById('mvRook').value = state.moveCost['ルーク'];
  document.getElementById('mvQueen').value = state.moveCost['クイーン'];
  document.getElementById('mvKing').value = state.moveCost['キング'];
  document.getElementById('inpDebug').value = state.debug?'on':'off';
  document.getElementById('settingsModal').classList.add('show');
});

document.getElementById('btnApplySettings').addEventListener('click', ()=>{
  state.size = +document.getElementById('inpSize').value;
  state.turnLimit = +document.getElementById('inpTurnLimit').value;
  state.life.red = +document.getElementById('inpLifeRed').value;
  state.life.blue = +document.getElementById('inpLifeBlue').value;
  state.moveCost['ポーン']   = +document.getElementById('mvPawn').value;
  state.moveCost['ナイト']   = +document.getElementById('mvKnight').value;
  state.moveCost['ビショップ']= +document.getElementById('mvBishop').value;
  state.moveCost['ルーク']   = +document.getElementById('mvRook').value;
  state.moveCost['クイーン'] = +document.getElementById('mvQueen').value;
  state.moveCost['キング']   = +document.getElementById('mvKing').value;
  state.debug = document.getElementById('inpDebug').value==='on';

  resetBoard(state.size);
  state.phase=0; state.turn=0; state.team='red';
  state.vp={red:0,blue:0};
  state.history=[];
  document.getElementById('settingsModal').classList.remove('show');
  renderAll();
});

document.getElementById('btnStart').addEventListener('click', ()=> startGame());
document.getElementById('btnMoveDone').addEventListener('click', ()=> commitMoves());
document.getElementById('btnUndo').addEventListener('click', ()=>{
  if(undoOnePhase()){ renderAll(); }
});

/* テンプレート機構（内容は後で拡張可能） */
const templates = {
  sampleA: {
    size: 8,
    cells: [
      {x:0,y:0,terrain:'respawn-red'},
      {x:7,y:7,terrain:'respawn-blue'}
    ],
    pieces: [
      {x:1,y:0,team:'red', type:'ポーン', name:'R1'},
      {x:2,y:0,team:'red', type:'ビショップ', name:'R2'},
      {x:6,y:7,team:'blue', type:'ポーン', name:'B1'},
      {x:5,y:7,team:'blue', type:'ビショップ', name:'B2'}
    ]
  },
  sampleB: {
    size: 10,
    cells: [
      {x:0,y:9,terrain:'respawn-red'},
      {x:9,y:0,terrain:'respawn-blue'},
      {x:4,y:4,terrain:'abyss'},{x:5,y:4,terrain:'abyss'},{x:4,y:5,terrain:'abyss'}
    ],
    pieces: [
      {x:1,y:9,team:'red', type:'ルーク', name:'R-ROOK'},
      {x:8,y:0,team:'blue', type:'ルーク', name:'B-ROOK'}
    ]
  }
};

document.getElementById('btnApplyTemplate').addEventListener('click', ()=>{
  const key = document.getElementById('inpTemplate').value;
  if(key==='none') return;
  const t = templates[key]; if(!t) return;
  // リセット
  resetBoard(t.size);
  // 地形
  (t.cells||[]).forEach(c=>{
    const cell = cellAt(c.x,c.y);
    cell.terrain = c.terrain;
  });
  // 駒
  (t.pieces||[]).forEach(p=>{
    placePiece(p.team, p.type, p.name, p.x, p.y);
  });
  // UI反映 & 値もセットしておく
  state.phase=0; state.turn=0; state.team='red'; state.vp={red:0,blue:0}; state.history=[];
  document.getElementById('inpSize').value = t.size;
  renderAll();
  // 設定モーダルは開いたままにしておく（他の数値をそのまま調整可能）
});

/* =========================
   初期化
========================= */
resetBoard(8);
renderAll();
</script>
</body>
</html>
