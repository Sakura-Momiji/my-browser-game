<!DOCTYPE html>
<html lang="ja">
<!-- 制作：さくらもみじ　無断配布禁止。 あと汚いコードを見るんじゃない。-->
<head>
    <meta charset="utf-8" />
    <title>シミュレーション（統合版）114</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            --cell: 52px;
            --grid-border: #333;
            --red: #f88;
            --red-text: #000;
            --blue: #88f;
            --blue-text: #fff;
            --abyss: #000;
            --respawn-r: #ffd5df;
            --respawn-b: #d5e9ff;
            --hilite: #ffe97a;
            --conflict: #b682ff;
            --red-info: rgb(255, 50, 50);
            --blue-info: rgb(50, 50, 255);
            --active-menu: #c2fbff;
        }

        body {
            font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
            background: #fafafa;
            margin: 16px;
            text-align: center
        }

        h1 {
            margin: .2rem 0 .6rem
        }

        #topbar {
            display: flex;
            flex-wrap: wrap;
            gap: .5rem;
            justify-content: center;
            align-items: center
        }

        button {
            cursor: pointer;
            border: none;
            border-radius: 10px;
            padding: .6rem .9rem;
            background: #4caf50;
            color: #fff;
            font-weight: 600
        }

        button.secondary {
            background: #607d8b
        }

        button.rule {
            background: #ffc547
        }

        button.warn {
            background: #e91e63
        }

        button:disabled {
            opacity: .5;
            cursor: not-allowed
        }

        #hud {
            margin: .6rem auto;
            display: flex;
            flex-wrap: wrap;
            gap: .8rem;
            justify-content: center;
            align-items: center
        }

        #hud .card {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 12px;
            padding: .4rem .8rem;
            min-width: 12ch
        }

        #underhub {
            display: flex;
            /* 横並び */
            gap: 10px;
            /* カード間の隙間 */

            justify-content: center;
            align-items: center;
            margin-bottom: 1rem;
            /* 下に余白を追加 */

            text-shadow:
                1px 1px 0 #000,
                /* 右下 */
                -1px -1px 0 #000,
                /* 左上 */
                1px -1px 0 #000,
                /* 右上 */
                -1px 1px 0 #000;
            /* 左下 */
        }

        .undercard {
            padding: 10px 20px;
            border-radius: 8px;
            color: #fff;
            font-weight: bold;
        }

        .redCard {
            background-color: var(--red-info, #f88);
        }

        .blueCard {
            background-color: var(--blue-info, #88f);
        }

        #whoseWrap {
            border-radius: 10px;
            padding: .2rem .6rem;
            color: #000
        }

        #movedone {
            display: flex;
            flex-wrap: wrap;
            gap: .5rem;
            justify-content: center;
            align-items: center
        }

        #boardOuter {
            display: inline-block;
            padding: 10px;
            border: 2px solid var(--grid-border);
            border-radius: 14px;
            background: #fff;
            margin-top: 12px
        }

        #boardWrap {
            position: relative;
            display: inline-block;
            margin: 0 auto;
            border-radius: 12px;
            padding: 10px;
            background: #fff
        }

        #board {
            display: grid;
            gap: 0
        }

        /* 矢印 (SVG) */
        #arrowLayer {
            position: absolute;
            inset: 10px;
            pointer-events: none;

            z-index: 9;
            /* 前面に表示 */
            opacity: 0.5;
            /* 半透明（0〜1で調整） */
        }


        .cell {
            width: var(--cell);
            height: var(--cell);
            border: 1px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-size: 12px;
            user-select: none
        }

        .label-x {
            position: absolute;
            top: -20px;
            left: 20px;
            font-size: 14px;
            color: #666
        }

        .label-y {
            position: absolute;
            left: -14px;
            top: 14px;
            font-size: 14px;
            color: #666
        }

        .abyss {
            background: var(--abyss) !important
        }

        .respawn-red {
            background: var(--respawn-r)
        }

        .respawn-blue {
            background: var(--respawn-b)
        }

        .piece {
            border-radius: 9px;
            padding: 2px 6px;
            font-weight: 700;
            min-width: calc(var(--cell) - 10px);
            text-align: center
        }

        .piece.red {
            background: var(--red);
            color: var(--red-text)
        }

        .piece.blue {
            background: var(--blue);
            color: var(--blue-text)
        }

        .highlight {
            outline: 3px solid var(--hilite);
            outline-offset: -3px
        }

        .conflict {
            box-shadow: inset 0 0 0 9999px color-mix(in srgb, var(--conflict) 35%, transparent)
        }

        /* 下部情報 */
        #selectionInfo {
            margin: .6rem auto;
            min-height: 1.6rem;
            color: #333
        }

        /* モーダル共通 */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .5);
            align-items: center;
            justify-content: center;
            padding: 16px;
            z-index: 10
        }

        /* 中身のパネル */
        .panel {
            background: #fff;
            padding: 16px;
            border-radius: 8px;
            max-height: 80vh;
            overflow-y: auto;
        }

        /* 通知 */
        .notice {
            color: green;
            margin-top: 8px;
        }

        .modal.show {
            display: flex
        }

        .modal .panel {
            background: #fff;
            border-radius: 14px;
            min-width: 320px;
            max-width: 92vw;
            padding: 16px;
            text-align: left;
            position: relative
        }

        .modal h2 {
            margin: .2rem 0 .6rem
        }

        /* 設定画面の右上の×印 */
        .closeX {
            position: absolute;
            top: 8px;
            right: 12px;
            background: transparent;
            /* 背景を透明に */
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #666;
            line-height: 1;
            padding: 4px 8px;
            /* クリックしやすく余白だけ残す */
            border-radius: 4px;
            /* hover背景を綺麗に見せる */
            transition: background-color 0.2s, color 0.2s;
        }

        .closeX:hover {
            background-color: #eee;
            /* ← 薄いグレー背景 */
            color: #000;
            /* アイコンは濃い色に */
        }

        .row {
            display: flex;
            gap: .5rem;
            align-items: center;
            flex-wrap: wrap;
            margin: .3rem 0
        }

        .row label {
            min-width: 9rem
        }

        input[type="number"] {
            width: 7rem;
            padding: .3rem
        }

        select,
        input[type="text"] {
            padding: .3rem
        }

        .hr {
            height: 1px;
            background: #eee;
            margin: .6rem 0
        }

        .rule-modal-content {
            display: flex;
            width: 80%;
            max-width: 800px;
            min-height: 40vh;
            /* 画面高さの40%確保 */
            min-height: 400px;
            /* ただし最低400px確保 */
            max-height: 90vh;
            /* はみ出すときはスクロール */
            background: #fff;
            border-radius: 8px;
            overflow: hidden;
            z-index: 11;
            /* 前面に表示 */
        }

        .rule-sidebar {
            width: 30%;
            background: #f0f0f0;
            padding: 1rem;
        }

        .rule-sidebar ul {
            list-style: none;
            padding: 0;
        }

        .rule-sidebar li {
            padding: 0.5rem;
            cursor: pointer;
        }

        .rule-sidebar li:hover {
            background: #ddd;
        }

        .rule-body {
            width: 70%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 1rem;
            overflow-y: auto;
            max-height: 400px;
        }

        #ruleBody {
            flex: 1;
            margin-bottom: 1rem;
        }

        /* ルール本文全体 */
        #ruleBody {
            text-align: center;
            /* デフォルトは中央揃え */
            line-height: 1.6;
            padding: 0.5rem;
        }

        /* 見出しは中央 */
        #ruleBody h2 {
            font-size: 1.3rem;
            margin-top: 0;
            margin-bottom: 0.5rem;
            border-bottom: 2px solid #ccc;
            padding-bottom: 0.3rem;
            text-align: center;
        }

        /* 段落は中央 */
        #ruleBody p {
            margin: 0.5rem 0;
            text-align: center;
            /* 段落も中央揃え */
        }

        /* 箇条書きは左揃え（番号付きも同じ） */
        #ruleBody ul,
        #ruleBody ol {
            text-align: left;
            /* 左揃え */
            margin: 0.5rem 1.5rem;
            padding-left: 1.2rem;
        }

        /* 強調用クラス */
        #ruleBody .keyword {
            font-weight: bold;
            color: #1d0086;
        }

        #ruleBody .win {
            color: green;
            font-weight: bold;
        }

        #ruleBody .lose {
            color: red;
            font-weight: bold;
        }

        #ruleBody .damage {
            color: crimson;
            font-weight: bold;
        }

        #ruleBody .highlight {
            background: yellow;
            padding: 0 0.2em;
            border-radius: 3px;
        }

        .rule-footer {
            text-align: right;
        }

        /* ルール説明の今選択している目次 */
        #ruleModal .toc li.active {
            background: var(--active-menu);
            font-weight: bold;
            border-left: 4px solid var(--blue);
            padding-left: 6px;
        }

        .modal.show {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .close-btn {
            margin-top: 1rem;
            padding: 0.5rem 1rem;
        }

        /* 以下設定画面モーダル */
        .settings-modal-content {
            position: relative;
            /* ←これ追加 */
            display: flex;
            flex-direction: row;
            width: 80vw;
            /* 画面幅の80% */
            max-width: 600px;
            /* PCではこれ以上広がらない */
            min-width: 280px;
            /* スマホでも潰れすぎない */
            min-height: 40vh;
            /* 画面高さの40%確保 */
            min-height: 400px;
            /* ただし最低400px確保 */
            max-height: 90vh;
            /* はみ出すときはスクロール */
            background: #fff;
            border-radius: 8px;
            overflow: hidden;
        }

        .settings-sidebar {
            width: 10vw;
            /* 画面幅の10% */
            max-width: 150px;
            /* PCではこれ以上広がらない */
            min-width: 90px;
            /* スマホでも潰れすぎない */
            min-height: 40vh;
            /* 画面高さの40%確保 */
            min-height: 400px;
            /* ただし最低400px確保 */
            max-height: 90vh;
            /* はみ出すときはスクロール */
            background: #f0f0f0;
            border-right: 1px solid #ccc;
            overflow-y: auto;
        }

        .settings-sidebar ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .settings-sidebar li {
            padding: 12px;
            cursor: pointer;
        }

        .settings-sidebar li.active {
            background: var(--active-menu);
            font-weight: bold;
        }

        .settings-body {
            flex: 1;
            overflow-y: auto;
            /* ここでスクロール */
            padding: 16px;
            padding-bottom: 60px;
            /* フッター分の余白確保 */
        }

        .settings-section {
            display: none;
        }

        .settings-section.active {
            display: block;
        }

        .settings-footer {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 100%;
            background: #fff;
            padding: 8px 16px;
            display: flex;
            justify-content: flex-end;
            border-top: 1px solid #ddd;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        #btnApplySettings {
            padding: 8px 16px;
            background-color: #4CAF50;
            /* お好みで色変更 */
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #btnApplySettings:hover {
            background-color: #45a049;
        }

        /* バトル一覧 */
        #battleList .battleRow {
            border: 1px solid #eee;
            border-radius: 10px;
            padding: 8px;
            margin: 6px 0;
            background: #fafbfd
        }

        #battleList .side {
            display: flex;
            flex-direction: column;
            gap: 3px;
            min-width: 10rem
        }

        .flex {
            display: flex;
            gap: .6rem;
            align-items: center;
            flex-wrap: wrap
        }

        .grow {
            flex: 1
        }

        .tag {
            font-size: 11px;
            border: 1px solid #ddd;
            border-radius: 999px;
            padding: .1rem .5rem;
            background: #fff
        }

        .note {
            font-size: 12px;
            color: #666
        }

        /* リザルト */
        #resultPanel h1 {
            font-size: 28px;
            margin: .2rem 0 .6rem
        }

        #resultPanel .stats {
            line-height: 1.9
        }

        /* テキスト移動指定のスタイル */
        #planInput {
            width: 10%;
            /* 横幅を親要素に合わせる */
            height: 100px;
            /* 高さ */
            padding: 8px;
            /* 内側余白 */
            font-family: monospace;
            /* JSON向きの等幅フォント */
            font-size: 14px;
            /* 文字サイズ */
            border: 1px solid #ccc;
            /* 枠線 */
            border-radius: 6px;
            /* 角丸 */
            background-color: #f9f9f9;
            /* 背景色 */
            resize: vertical;
            /* 高さだけ調整可能、横幅は固定 */
            overflow-y: auto;
            /* 縦スクロール */
        }

        .plan-row {
            display: flex;
            align-items: flex-start;
            /* 縦方向は上揃え */
            justify-content: center;
            /* 横方向中央揃え */
            gap: 8px;
            /* 要素間の隙間 */
            margin-bottom: 12px;
            /* 下に余白 */
        }

        /* 1フェーズ戻るのスタイル */
        .undo-row {
            text-align: center;
            margin-top: 8px;
        }
    </style>
</head>

<body>
    <h1>シミュレーション（統合版）</h1>

    <div id="topbar">
        <button id="btnSettings" class="secondary">設定</button>
        <button id="btnStart">ゲーム開始</button>
        <button id="btnRule" class="rule">ルール説明</button>
    </div>

    <div id="hud">
        <div class="card">ターン: <span id="turnNow">0</span> / <span id="turnLimit">10</span></div>
        <div class="card">現在: <span id="whoseWrap"><span id="whoseTurn">準備段階</span></span> <span id="phaseTag"
                class="tag" style="display:none"></span></div>
    </div>

    <div id="movedone">
        <button id="exportBtn">移動プランナー生成</button>
        <button id="btnMoveDone" disabled>コマの移動を決定する</button>
    </div>

    <div id="boardOuter">
        <div id="boardWrap">
            <svg id="arrowLayer"></svg>
            <div id="board"></div>
        </div>
    </div>


    <div id="selectionInfo"></div>

    <div id="underhub">
        <div class="undercard redCard">
            赤ライフ: <span id="lifeRed">10</span><br>勝利Pt: <span id="vpRed">0</span>
        </div>
        <div class="undercard blueCard">
            青ライフ: <span id="lifeBlue">10</span><br>勝利Pt: <span id="vpBlue">0</span>
        </div>
    </div>
    <p>移動プランナー</p>
    <div class="plan-row">
        <textarea id="planInput" placeholder='例{"Pawn1":{"x":2,"y":3}}'></textarea>
        <button onclick="applyPlanFromText(document.getElementById('planInput').value)">プランナーを適用</button>
        <button onclick="clearPlanInput()" class="warn">プランナーを削除</button>
    </div>
    <div class="undo-row">
        <button id="btnUndo" class="warn" disabled>（1フェーズ戻る）</button>
    </div>

    <!-- 設定モーダル -->
    <div id="settingsModal" class="modal">
        <div class="modal-content settings-modal-content">
            <!-- 右上の×印 -->
            <button class="closeX" id="closeSettings">×</button>

            <!-- 左メニューは自動生成 -->
            <div class="settings-sidebar">
                <ul id="settingsMenu" class="toc"></ul>
            </div>

            <!-- 右側セクション群 -->
            <div class="settings-body">
                <div id="basicSettings" class="settings-section" data-title="基本設定">
                    <h3>基本設定</h3>
                    <div class="row"><label>テンプレート</label>
                        <select id="inpTemplate">
                            <option value="none">（選択なし）</option>
                            <option value="reset">リセット</option>
                            <option value="vs6">6VS6</option>
                            <option value="vs4">4VS4</option>
                            <option value="vs3d">3VS3デスマッチ</option>
                            <option value="debug1">デバッグ1</option>
                        </select>
                        <button id="btnApplyTemplate" class="secondary">テンプレ適用</button>
                    </div>
                    <div class="row"><label>盤面の大きさ</label><input type="number" id="inpSize" min="3" max="30" value="8">
                    </div>
                    <div class="row"><label>ターン数</label><input type="number" id="inpTurnLimit" min="1" max="200"
                            value="10"></div>
                    <div class="row"><label>赤ライフ</label><input type="number" id="inpLifeRed" min="1" max="99"
                            value="10"></div>
                    <div class="row"><label>青ライフ</label><input type="number" id="inpLifeBlue" min="1" max="99"
                            value="10"></div>
                </div>

                <div id="moveSettings" class="settings-section" data-title="移動距離">
                    <h3>移動距離（コスト上限）</h3>
                    <div class="row"><label>ポーン</label><input type="number" id="mvPawn" min="1" max="12" value="3">
                    </div>
                    <div class="row"><label>ナイト</label><input type="number" id="mvKnight" min="1" max="12" value="4">
                    </div>
                    <div class="row"><label>ビショップ</label><input type="number" id="mvBishop" min="1" max="12" value="5">
                    </div>
                    <div class="row"><label>ルーク</label><input type="number" id="mvRook" min="1" max="12" value="6">
                    </div>
                    <div class="row"><label>クイーン</label><input type="number" id="mvQueen" min="1" max="12" value="6">
                    </div>
                    <div class="row"><label>キング</label><input type="number" id="mvKing" min="1" max="12" value="3">
                    </div>
                </div>

                <div id="specialRules" class="settings-section" data-title="特殊ルール">
                    <h3>特殊ルール</h3>
                    <div class="row"><label>キングアタック</label><input type="number" id="kingAttackDamage" min="1" max="99"
                            value="1"></div>
                </div>

                <div id="debugSettings" class="settings-section" data-title="デバッグ">
                    <h3>デバッグモード</h3>
                    <div class="row"><label>デバッグモード</label>
                        <select id="inpDebug">
                            <option value="off">OFF</option>
                            <option value="on">ON</option>
                        </select>
                    </div>
                </div>

                <div class="settings-footer">
                    <div class="note">設定を適用すると盤面はリセットされ、フェーズ0（準備）に戻ります。</div>
                    <button id="btnApplySettings">適用</button>
                </div>
            </div>
        </div>
    </div>



    <!-- 配置/編集モーダル（フェーズ0のみ） -->
    <div id="placeModal" class="modal">
        <div class="panel">
            <div class="closeX" data-close="placeModal">×</div>
            <h2 id="placeTitle">配置 / 編集</h2>
            <div class="row">
                <label>種類</label>
                <select id="selKind">
                    <option value="piece">コマ</option>
                    <option value="gimmick">ギミック</option>
                </select>
            </div>
            <div id="optPiece">
                <div class="row"><label>色</label>
                    <select id="selTeam">
                        <option value="red">赤</option>
                        <option value="blue">青</option>
                    </select>
                </div>
                <div class="row"><label>タイプ</label>
                    <select id="selType">
                        <option>ポーン</option>
                        <option>ナイト</option>
                        <option>ビショップ</option>
                        <option>ルーク</option>
                        <option>クイーン</option>
                        <option>キング</option>
                    </select>
                </div>
                <div class="row"><label>名前</label><input id="inpName" type="text" placeholder="未入力はタイプ名"></div>
            </div>
            <div id="optGimmick" style="display:none">
                <div class="row"><label>ギミック</label>
                    <select id="selGimmick">
                        <option value="abyss">奈落</option>
                        <option value="respawn">リスポーンエリア</option>
                    </select>
                </div>
                <div class="row" id="rowRespawnColor"><label>色（リスポーン）</label>
                    <select id="selRespawnTeam">
                        <option value="red">赤</option>
                        <option value="blue">青</option>
                    </select>
                </div>
            </div>
            <div class="row" style="justify-content:flex-end;gap:.5rem">
                <button id="btnPlaceApply">適用</button>
                <button id="btnDelete" class="warn">削除</button>
            </div>
        </div>
    </div>

    <!-- バトルモーダル（赤/引分/青） -->
    <div id="battleModal" class="modal">
        <div class="panel">
            <h2>バトル結果を選択</h2>
            <div id="battleList"></div>
            <div class="row" style="justify-content:space-between;align-items:center">
                <span id="battleWarn" class="note" style="display:none;color:#d32f2f">まだ勝敗が決まっていない試合があります</span>
                <button id="btnBattleConfirm">決定</button>
            </div>
        </div>
    </div>

    <!-- リザルト -->
    <div id="resultModal" class="modal">
        <div id="resultPanel" class="panel">
            <h1 id="winnerText"></h1>
            <div class="stats">
                <div>経過ターン数: <span id="resTurns"></span></div>
                <div>赤ライフ: <span id="resLifeR"></span>　青ライフ: <span id="resLifeB"></span></div>
                <div>赤勝利Pt: <span id="resVpR"></span>　青勝利Pt: <span id="resVpB"></span></div>
            </div>
            <div class="row" style="justify-content:flex-end;margin-top:.6rem">
                <button id="btnCloseResult">閉じる</button>
            </div>
        </div>
    </div>


    <!-- ルール説明モーダル -->
    <div id="ruleModal" class="modal">
        <div class="modal-content rule-modal-content">
            <div class="rule-sidebar">
                <ul id="ruleList" class="toc"></ul>
            </div>
            <div class="rule-body">
                <div id="ruleBody">ルールの内容がここに表示されます</div>
                <div class="rule-footer">
                    <button class="close-btn" id="closeRule">閉じる</button>
                </div>
            </div>
        </div>
    </div>

    <!-- テキスト仮移動指定エラーモーダル -->
    <div id="planModal" class="modal" style="display:none;">
        <div class="panel">
            <span id="closeModal" style="cursor:pointer;">&times;</span>
            <h3>以下のコマは移動できませんでした：</h3>
            <ul id="modalList"></ul>
        </div>
    </div>

    <!-- 文字列生成モーダル -->
    <div id="planExportModal" class="modal">
        <div class="panel">
            <button class="closeX" id="closePlanExportModal">×</button>
            <h2>以下のテキストをコピーしました</h2>
            <pre id="planExportText"></pre>
            <button id="copyAgainBtn">再度コピー</button>
            <div id="copyNotice" class="notice" style="display:none;"></div>
        </div>
    </div>



    <script>
        /* =========================
           データ構造
        ========================= */
        const boardEl = document.getElementById('board');
        const arrowLayer = document.getElementById('arrowLayer');

        const state = {
            size: 8,
            turnLimit: 10,
            life: { red: 10, blue: 10 },
            kingAttackDamage: 1,
            debug: false,
            moveCost: { 'ポーン': 3, 'ナイト': 4, 'ビショップ': 5, 'ルーク': 6, 'クイーン': 6, 'キング': 3 },

            phase: 0,                 // 0=準備, 1=赤, 2=青, 3=赤...
            turn: 0,                  // 両軍完了で+1
            team: 'red',              // 現在の行動側
            vp: { red: 0, blue: 0 },

            cells: [],                // [y][x] = { terrain:'empty'|'abyss'|'respawn-red'|'respawn-blue', pieces:[pieceId,...] }
            pieces: {},               // id -> {id, team, type, name, x, y, alive:true, moved:false, plan:{x,y,ox,oy}}
            nextId: 1,

            arrows: [],               // {id, from:{x,y}, to:{x,y}}

            history: []               // JSON snapshots（1フェーズ戻る用：スタック）
        };

        function deepCopy(obj) { return JSON.parse(JSON.stringify(obj)); }
        function pushHistory() {
            state.history.push(JSON.stringify({
                size: state.size, turnLimit: state.turnLimit, life: state.life, debug: state.debug, moveCost: state.moveCost,
                phase: state.phase, turn: state.turn, team: state.team, vp: state.vp,
                cells: state.cells, pieces: state.pieces, nextId: state.nextId, arrows: state.arrows
            }));
        }
        function undoOnePhase() {
            if (!state.history.length) return false;
            const snap = JSON.parse(state.history.pop());
            Object.assign(state, snap);
            renderAll();
            return true;
        }

        /* =========================
           ユーティリティ
        ========================= */
        function numToCol(n) { let s = ""; while (n >= 0) { s = String.fromCharCode((n % 26) + 65) + s; n = Math.floor(n / 26) - 1; } return s; }
        function inBounds(x, y) { return x >= 0 && y >= 0 && x < state.size && y < state.size; }
        function cellAt(x, y) { return state.cells[y][x]; }
        function pieceById(id) { return state.pieces[id]; }
        function teamOpp(t) { return t === 'red' ? 'blue' : 'red'; }
        function isRespawnTerrain(t) { return t === 'respawn-red' || t === 'respawn-blue'; }

        /* =========================
           盤面生成・描画
        ========================= */
        function resetBoard(size = state.size) {
            state.size = size;
            state.cells = Array.from({ length: size }, (_, y) =>
                Array.from({ length: size }, (_, x) => ({ terrain: 'empty', pieces: [] })));
            state.pieces = {};
            state.nextId = 1;
            state.arrows = [];
        }

        function renderBoard() {
            boardEl.innerHTML = '';
            boardEl.style.gridTemplateColumns = `repeat(${state.size}, var(--cell))`;

            const svgW = state.size * parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'));
            arrowLayer.setAttribute('viewBox', `0 0 ${svgW} ${svgW}`);
            arrowLayer.innerHTML = '';
            addArrowMarker();

            for (let y = 0; y < state.size; y++) {
                for (let x = 0; x < state.size; x++) {
                    const c = document.createElement('div');
                    c.className = 'cell';
                    c.dataset.x = x; c.dataset.y = y;

                    if (y === 0) { const lx = document.createElement('div'); lx.className = 'label-x'; lx.textContent = numToCol(x); c.appendChild(lx); }
                    if (x === 0) { const ly = document.createElement('div'); ly.className = 'label-y'; ly.textContent = y + 1; c.appendChild(ly); }

                    const cell = cellAt(x, y);
                    if (cell.terrain === 'abyss') c.classList.add('abyss');
                    if (cell.terrain === 'respawn-red') c.classList.add('respawn-red');
                    if (cell.terrain === 'respawn-blue') c.classList.add('respawn-blue');

                    cell.pieces.forEach(id => {
                        const p = pieceById(id); if (!p || !p.alive) return;
                        const chip = document.createElement('div');
                        chip.className = `piece ${p.team}`;
                        chip.textContent = p.name;
                        c.appendChild(chip);
                    });

                    const teamsHere = new Set(cell.pieces.map(id => pieceById(id)?.team).filter(Boolean));
                    if (teamsHere.size >= 2 && !isRespawnTerrain(cell.terrain)) c.classList.add('conflict');

                    c.addEventListener('click', () => onCellClick(x, y));
                    boardEl.appendChild(c);
                }
            }
            drawArrows();
        }

        function renderHUD() {
            document.getElementById('lifeRed').textContent = state.life.red;
            document.getElementById('lifeBlue').textContent = state.life.blue;
            document.getElementById('vpRed').textContent = state.vp.red;
            document.getElementById('vpBlue').textContent = state.vp.blue;
            document.getElementById('turnLimit').textContent = state.turnLimit;
            document.getElementById('turnNow').textContent = state.turn;

            const phaseTag = document.getElementById('phaseTag');
            if (state.debug) { phaseTag.style.display = 'inline-block'; phaseTag.textContent = `フェーズ ${state.phase}`; }
            else { phaseTag.style.display = 'none'; }

            const whoseWrap = document.getElementById('whoseWrap');
            const whoseTurn = document.getElementById('whoseTurn');
            if (state.phase === 0) {
                whoseTurn.textContent = '準備段階';
                whoseWrap.style.background = 'transparent';
                whoseWrap.style.color = '#000';
            } else {
                const isRed = state.team === 'red';
                whoseTurn.textContent = (isRed ? '赤' : '青') + ' のターン';
                whoseWrap.style.background = isRed ? 'var(--red)' : 'var(--blue)';
                whoseWrap.style.color = isRed ? 'var(--red-text)' : 'var(--blue-text)';
            }

            document.getElementById('btnMoveDone').disabled = (state.phase === 0);
            document.getElementById('btnStart').disabled = (state.phase !== 0);
            document.getElementById('btnUndo').disabled = (state.history.length === 0);
        }

        function renderAll() { renderBoard(); renderHUD(); }

        /* =========================
           ピース / 配置
        ========================= */
        function placePiece(team, type, name, x, y) {
            const id = state.nextId++;
            const p = { id, team, type, name: name || type, x, y, alive: true, moved: false, plan: null };
            state.pieces[id] = p;
            cellAt(x, y).pieces.push(id);
            return p;
        }
        function removePieceFromCell(id) {
            const p = pieceById(id); if (!p) return;
            const arr = cellAt(p.x, p.y).pieces;
            const k = arr.indexOf(id); if (k >= 0) arr.splice(k, 1);
        }
        function movePieceTo(id, x, y) {
            const p = pieceById(id); if (!p) return;
            removePieceFromCell(id);
            p.x = x; p.y = y;
            cellAt(x, y).pieces.push(id);
        }

        // リスポーン地点 を探す(初期設定)
        function findRespawnCell(team) {
            for (let y = 0; y < state.size; y++) for (let x = 0; x < state.size; x++) {
                const t = cellAt(x, y).terrain;
                if ((team === 'red' && t === 'respawn-red') || (team === 'blue' && t === 'respawn-blue')) return { x, y };
            }
            return null;
        }

        // リスポーン地点 かつ 駒がいない場所を探す
        function findEmptyRespawnCell(team) {
            const target = (team === 'red') ? 'respawn-red' : 'respawn-blue';

            for (let y = 0; y < state.size; y++) {
                for (let x = 0; x < state.size; x++) {
                    const cell = cellAt(x, y);
                    if (cell.terrain === target && cell.pieces.length === 0) {
                        // そのチームのリスポーン地点 かつ 駒がいない場所
                        return { x, y };
                    }
                }
            }
            return null; // 空きがなければ null
        }

        /* =========================
           準備段階：配置/編集モーダル
        ========================= */
        const placeModal = document.getElementById('placeModal');
        let selectedCellCoord = null;
        let editingExisting = null;

        document.querySelectorAll('.closeX').forEach(x => x.addEventListener('click', e => {
            const id = e.target.getAttribute('data-close'); document.getElementById(id).classList.remove('show');
        }));
        document.getElementById('selKind').addEventListener('change', e => {
            const piece = document.getElementById('optPiece');
            const gim = document.getElementById('optGimmick');
            if (e.target.value === 'piece') { piece.style.display = 'block'; gim.style.display = 'none'; }
            else { piece.style.display = 'none'; gim.style.display = 'block'; }
        });
        document.getElementById('selGimmick').addEventListener('change', e => {
            document.getElementById('rowRespawnColor').style.display = (e.target.value === 'respawn') ? 'flex' : 'none';
        });

        function onCellClick(x, y) {
            if (state.phase !== 0) { onCellClickDuringTurn(x, y); return; }
            selectedCellCoord = { x, y };
            const cell = cellAt(x, y);
            const occupiedPieceId = cell.pieces[0] ?? null;
            editingExisting = null;
            if (occupiedPieceId) {
                const p = pieceById(occupiedPieceId);
                document.getElementById('selKind').value = 'piece';
                document.getElementById('optPiece').style.display = 'block';
                document.getElementById('optGimmick').style.display = 'none';
                document.getElementById('selTeam').value = p.team;
                document.getElementById('selType').value = p.type;
                document.getElementById('inpName').value = p.name;
                editingExisting = p.id;
            } else if (cell.terrain !== 'empty') {
                document.getElementById('selKind').value = 'gimmick';
                document.getElementById('optPiece').style.display = 'none';
                document.getElementById('optGimmick').style.display = 'block';
                if (cell.terrain === 'abyss') document.getElementById('selGimmick').value = 'abyss';
                if (cell.terrain === 'respawn-red') { document.getElementById('selGimmick').value = 'respawn'; document.getElementById('selRespawnTeam').value = 'red'; }
                if (cell.terrain === 'respawn-blue') { document.getElementById('selGimmick').value = 'respawn'; document.getElementById('selRespawnTeam').value = 'blue'; }
                editingExisting = cell.terrain;
            } else {
                document.getElementById('selKind').value = 'piece';
                document.getElementById('optPiece').style.display = 'block';
                document.getElementById('optGimmick').style.display = 'none';
                document.getElementById('inpName').value = '';
            }
            document.getElementById('placeTitle').textContent = '配置 / 編集';
            placeModal.classList.add('show');
        }

        document.getElementById('btnDelete').addEventListener('click', () => {
            if (!selectedCellCoord) return;
            const { x, y } = selectedCellCoord;
            const cell = cellAt(x, y);
            if (editingExisting && typeof editingExisting === 'number') {
                const id = editingExisting;
                removePieceFromCell(id);
                delete state.pieces[id];
            } else if (editingExisting) {
                cell.terrain = 'empty';
            }
            placeModal.classList.remove('show');
            renderAll();
        });

        document.getElementById('btnPlaceApply').addEventListener('click', () => {
            if (!selectedCellCoord) return;
            const { x, y } = selectedCellCoord;
            const cell = cellAt(x, y);

            const kind = document.getElementById('selKind').value;
            if (kind === 'piece') {
                if (cell.pieces.length) { const id = cell.pieces[0]; delete state.pieces[id]; cell.pieces = []; }
                const team = document.getElementById('selTeam').value;
                const type = document.getElementById('selType').value;
                const name = document.getElementById('inpName').value.trim() || type;
                placePiece(team, type, name, x, y);
            } else {
                const g = document.getElementById('selGimmick').value;
                if (g === 'abyss') cell.terrain = 'abyss';
                else {
                    const t = document.getElementById('selRespawnTeam').value;
                    cell.terrain = t === 'red' ? 'respawn-red' : 'respawn-blue';
                }
                while (cell.pieces.length) { const id = cell.pieces.pop(); delete state.pieces[id]; }
            }
            placeModal.classList.remove('show');
            renderAll();
        });

        /* =========================
           ターン開始/移動/仮移動
        ========================= */
        let reachable = new Set(); // "x,y"
        let selectedPieceId = null;

        function startGame() {
            if (state.phase !== 0) return;
            pushHistory(); // 0→1 へ移る前のスナップショット（Undo用）
            state.phase = 1; state.team = 'red'; state.turn = 1;
            for (const p of Object.values(state.pieces)) { p.moved = false; p.plan = null; }
            state.arrows = [];
            renderAll();
        }

        function onCellClickDuringTurn(x, y) {
            const cell = cellAt(x, y);
            const ownIds = cell.pieces.filter(id => pieceById(id)?.team === state.team && pieceById(id)?.alive);
            const candidate = ownIds.map(id => pieceById(id)).find(p => !p.moved);
            if (candidate) { selectPiece(candidate.id); return; }

            const key = `${x},${y}`;
            if (selectedPieceId && reachable.has(key)) { planMove(selectedPieceId, x, y); return; }

            clearSelection();
        }

        function selectPiece(id) {
            selectedPieceId = id;
            const p = pieceById(id);
            document.getElementById('selectionInfo').textContent = `選択中: ${p.name}（${p.type} / ${p.team === 'red' ? '赤' : '青'}）`;
            computeReachable(id);
            renderBoardHighlights();
        }

        function clearSelection() {
            selectedPieceId = null;
            reachable.clear();
            document.getElementById('selectionInfo').textContent = '';
            renderBoardHighlights();
        }

        /* 可動範囲：同一ターンの仮移動先（plan）には入れない。 */
        function computeReachable(id) {
            reachable.clear();
            const p = pieceById(id); if (!p) return;
            const maxCost = state.moveCost[p.type] ?? 3;

            const plannedSet = new Set(); // "x,y"
            for (const q of Object.values(state.pieces)) {
                if (q.alive && q.plan) { plannedSet.add(`${q.plan.x},${q.plan.y}`); }
            }

            const Q = [{ x: p.x, y: p.y, cost: 0 }];
            const seen = new Set([`${p.x},${p.y}`]);

            while (Q.length) {
                const cur = Q.shift();
                const dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]];
                for (const [dx, dy] of dirs) {
                    const nx = cur.x + dx, ny = cur.y + dy, nc = cur.cost + 1;
                    const k = `${nx},${ny}`;
                    if (!inBounds(nx, ny) || nc > maxCost || seen.has(k)) continue;
                    const c = cellAt(nx, ny);
                    if (c.terrain === 'abyss') continue;

                    const alliesHere = c.pieces.map(id => pieceById(id)).filter(pp => pp && pp.team === p.team);

                    const isBlocked = alliesHere.length || plannedSet.has(k);

                    // 移動可能マスとして追加するか
                    if (!isBlocked) {
                        reachable.add(k);
                    }

                    // 探索は続ける（障害物だけはcontinue）
                    if (c.terrain === 'abyss') continue;

                    // キューに追加して次のマスを探索
                    seen.add(k);
                    Q.push({ x: nx, y: ny, cost: nc });
                }
            }
            reachable.delete(`${p.x},${p.y}`);
        }

        function renderBoardHighlights() {
            renderBoard();
            if (!selectedPieceId) return;
            document.querySelectorAll('#board .cell').forEach(el => {
                const x = +el.dataset.x, y = +el.dataset.y;
                if (reachable.has(`${x},${y}`)) el.classList.add('highlight');
            });
        }

        function planMove(id, x, y) {
            const p = pieceById(id); if (!p) return;

            // 目的地が他の仮移動先なら拒否
            const dest = cellAt(x, y);
            const isAnyRespawn = isRespawnTerrain(dest.terrain);
            if (!isAnyRespawn) {
                for (const q of Object.values(state.pieces)) {
                    if (q.plan && q.plan.x === x && q.plan.y === y && q.id !== p.id) {
                        return; // 取り合い禁止
                    }
                }
            }

            // 以前のプラン矢印を消す
            if (p.plan) { state.arrows = state.arrows.filter(a => a.id !== p.id); }

            p.plan = { x, y, ox: p.x, oy: p.y };
            p.moved = false; // これをtrueにすると仮移動の選択しなおしができなくなる。

            // 同色同マスの競合：リスポーン地形なら多重OK、そうでなければ後勝ち優先で先のプランを取消
            if (!isAnyRespawn) {
                for (const q of Object.values(state.pieces)) {
                    if (q.id !== p.id && q.alive && q.team === p.team && q.plan && q.plan.x === x && q.plan.y === y) {
                        q.plan = null; q.moved = false;
                    }
                }
            }

            state.arrows.push({ id: p.id, from: { x: p.x, y: p.y }, to: { x, y } });

            clearSelection();
            renderBoardHighlights();
        }
        //----------------
        //現在の仮移動プランを JSON 文字列にして textarea に表示する関数
        //----------------
        // 文字列生成・コピー・モーダル表示
        function exportPlanToClipboardAndShowModal() {
            const planExportObj = {};
            for (const p of Object.values(state.pieces)) {
                if (p.alive && p.plan) {
                    planExportObj[p.name] = { x: p.plan.x, y: p.plan.y };
                }
            }
            const text = JSON.stringify(planExportObj, null, 2);

            // コピー
            copyTextToClipboard(text);

            // モーダルに反映して表示
            document.getElementById("planExportText").textContent = text;
            document.getElementById("planExportModal").style.display = "flex";

            // 「コマの移動を決定する」ボタンを有効化
            document.getElementById("btnMoveDone").disabled = false;

            // 通知を表示
            showCopyNotice("テキストをコピーしました！");
        }

        // コピー再実行
        function copyPlanAgain() {
            const text = document.getElementById("planExportText").textContent;
            copyTextToClipboard(text);
            showCopyNotice("再度コピーしました！");
        }

        // モーダル閉じる
        function closePlanModal() {
            document.getElementById("planExportModal").style.display = "none";
        }

        // テキストをクリップボードにコピー
        function copyTextToClipboard(text) {
            navigator.clipboard.writeText(text).catch(err => {
                console.error("コピー失敗", err);
            });
        }

        // 通知表示（数秒で自動消滅）
        function showCopyNotice(msg, replaceMsg = "対戦相手やGMにテキストを送ってください") {
            const el = document.getElementById("copyNotice");
            el.textContent = msg;
            el.style.display = "block";

            setTimeout(() => {
                el.textContent = replaceMsg;  // 置き換えるテキスト
                el.style.display = replaceMsg ? "block" : "none"; // 空文字なら非表示
            }, 2000);
        }

        // イベント登録
        document.addEventListener("DOMContentLoaded", () => {
            document.getElementById("exportBtn").addEventListener("click", exportPlanToClipboardAndShowModal);
            document.getElementById("copyAgainBtn").addEventListener("click", copyPlanAgain);
            document.getElementById("closePlanExportModal").addEventListener("click", closePlanModal);
        });


        //----------------
        //テキスト仮移動指定エラーモーダル表示用関数
        //----------------
        function showModalForUnreachable(unreachablePieces) {
            const listEl = document.getElementById('modalList');
            listEl.innerHTML = ''; // リストをクリア

            for (const p of unreachablePieces) {
                const li = document.createElement('li');
                li.textContent = `${p.name}（${p.type} / ${p.team === 'red' ? '赤' : '青'}）`;
                listEl.appendChild(li);
            }

            const modal = document.getElementById('planModal');
            modal.style.display = 'flex';

            document.getElementById('closeModal').onclick = () => {
                modal.style.display = 'none';
            };
        }

        //----------------
        //テキストから仮移動を適用する関数
        //----------------
        function applyPlanFromText(jsonText) {
            let planObj;
            try {
                planObj = JSON.parse(jsonText);
            } catch (e) {
                alert("JSON解析に失敗しました。形式を確認してください。");
                return;
            }

            const unreachable = [];

            for (const [name, pos] of Object.entries(planObj)) {
                const piece = Object.values(state.pieces).find(p => p.name === name && p.alive);
                if (piece && pos.x != null && pos.y != null) {
                    computeReachable(piece.id); // 可動範囲を更新
                    if (reachable.has(`${pos.x},${pos.y}`)) {
                        planMove(piece.id, pos.x, pos.y);
                    } else {
                        unreachable.push(piece);
                    }
                }
            }

            if (unreachable.length > 0) {
                showModalForUnreachable(unreachable);
            }
        }
        //テキストエリアの文字を消す
        //----------------
        function clearPlanInput() {
            document.getElementById('planInput').value = '';
        }


        function commitMoves() {
            // 本確定の前に履歴を積む（Undoでこのフェーズに戻れる）
            pushHistory();

            // 仮移動を本移動へ
            for (let y = 0; y < state.size; y++) for (let x = 0; x < state.size; x++) state.cells[y][x].pieces = [];

            for (const p of Object.values(state.pieces)) {
                if (!p.alive) continue;
                if (p.plan) { p.x = p.plan.x; p.y = p.plan.y; }
                state.cells[p.y][p.x].pieces.push(p.id);
            }

            // 敵リスポーン踏み：ダメージ→自軍リスポーンへワープ（ここではバトルを発生させない）
            processEnemyRespawnCaptures();

            // バトル対象セル（リスポーン上は除外）
            const conflicts = collectConflicts();
            renderAll();
            if (conflicts.length) { openBattleModal(conflicts); }
            else { endTurn(); }
        }

        function processEnemyRespawnCaptures() {
            const warpQueue = [];
            let dmgRed = 0, dmgBlue = 0; // 受けるダメージのカウンター
            for (let y = 0; y < state.size; y++) for (let x = 0; x < state.size; x++) {
                const cell = cellAt(x, y);
                // 赤のリスポーンに青駒が侵入していたら → 赤のライフが減る
                if (cell.terrain === 'respawn-red') {
                    const blues = cell.pieces.map(id => pieceById(id))
                        .filter(p => p && p.team === 'blue');
                    if (blues.length) {
                        blues.forEach(p => {
                            if (p.type === 'キング') {
                                dmgRed += state.kingAttackDamage; // キングは特別ダメージ
                            } else {
                                dmgRed += 1; // それ以外は1ダメージ
                            }
                            warpQueue.push(p);// 青駒はリスポーンで弾き返す
                        });
                    }
                }
                // 同様に青の処理
                if (cell.terrain === 'respawn-blue') {
                    const reds = cell.pieces.map(id => pieceById(id))
                        .filter(p => p && p.team === 'red');
                    if (reds.length) {
                        reds.forEach(p => {
                            if (p.type === 'キング') {
                                dmgBlue += state.kingAttackDamage;
                            } else {
                                dmgBlue += 1;
                            }
                            warpQueue.push(p);
                        });
                    }
                }
            }
            if (dmgRed) state.life.red = Math.max(0, state.life.red - dmgRed);
            if (dmgBlue) state.life.blue = Math.max(0, state.life.blue - dmgBlue);

            // リスポーンする時の処理
            warpQueue.forEach(p => {
                removePieceFromCell(p.id);
                const sp = findEmptyRespawnCell(p.team);
                if (sp) movePieceTo(p.id, sp.x, sp.y);
                else p.alive = false;
            });
        }

        function collectConflicts() {
            const list = [];
            for (let y = 0; y < state.size; y++) for (let x = 0; x < state.size; x++) {
                const cell = cellAt(x, y);
                if (isRespawnTerrain(cell.terrain)) continue; // リスポーン上は戦闘しない（ライフ処理優先）
                const reds = cell.pieces.map(id => pieceById(id)).filter(p => p && p.team === 'red');
                const blues = cell.pieces.map(id => pieceById(id)).filter(p => p && p.team === 'blue');
                if (reds.length && blues.length) {
                    list.push({ x, y, red: reds[0], blue: blues[0], result: null });
                }
            }
            return list;
        }

        /* =========================
           矢印描画
        ========================= */
        function addArrowMarker() {
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '8'); marker.setAttribute('markerHeight', '8');
            marker.setAttribute('refX', '6'); marker.setAttribute('refY', '3'); marker.setAttribute('orient', 'auto');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M0,0 L6,3 L0,6 z'); path.setAttribute('fill', '#444');
            marker.appendChild(path); defs.appendChild(marker); arrowLayer.appendChild(defs);
        }
        function drawArrows() {
            const cellPx = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'));
            for (const a of state.arrows) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                const x1 = a.from.x * cellPx + cellPx / 2;
                const y1 = a.from.y * cellPx + cellPx / 2;
                const x2 = a.to.x * cellPx + cellPx / 2;
                const y2 = a.to.y * cellPx + cellPx / 2;
                line.setAttribute('x1', x1); line.setAttribute('y1', y1);
                line.setAttribute('x2', x2); line.setAttribute('y2', y2);
                line.setAttribute('stroke', '#444'); line.setAttribute('stroke-width', '3');
                line.setAttribute('marker-end', 'url(#arrowhead)');
                arrowLayer.appendChild(line);
            }
        }

        /* =========================
           バトルモーダル（赤/引分/青）
        ========================= */
        const battleModal = document.getElementById('battleModal');
        const battleListEl = document.getElementById('battleList');
        const battleWarn = document.getElementById('battleWarn');
        let battles = []; // {x,y, red, blue, result}

        function openBattleModal(conflicts) {
            battles = conflicts;
            battleListEl.innerHTML = '';
            conflicts.forEach((b, idx) => {
                const row = document.createElement('div');
                row.className = 'battleRow';
                row.innerHTML = `
      <div class="flex" style="justify-content:space-between;gap:12px">
        <div class="side">
          <strong>${b.red.name}</strong>
          <span class="tag">赤 / ${b.red.type}</span>
        </div>
        <div class="grow" style="text-align:center">VS<br><span class="tag">マス ${numToCol(b.x)}-${b.y + 1}</span></div>
        <div class="side" style="text-align:right">
          <strong>${b.blue.name}</strong>
          <span class="tag">青 / ${b.blue.type}</span>
        </div>
      </div>
      <div class="flex" style="justify-content:center;margin-top:6px">
        <button data-ans="red">赤の勝ち</button>
        <button data-ans="draw" class="secondary">引き分け</button>
        <button data-ans="blue">青の勝ち</button>
      </div>
    `;
                row.querySelectorAll('button').forEach(btn => {
                    btn.addEventListener('click', () => {
                        b.result = btn.getAttribute('data-ans');
                        row.querySelectorAll('button').forEach(b2 => b2.disabled = false);
                        btn.disabled = true;
                        battleWarn.style.display = 'none';
                    });
                });
                battleListEl.appendChild(row);
            });
            battleModal.classList.add('show');
        }

        document.getElementById('btnBattleConfirm').addEventListener('click', () => {
            if (battles.some(b => !b.result)) { battleWarn.style.display = 'inline'; return; }
            for (const b of battles) {
                if (b.result === 'red' || b.result === 'blue') {
                    const winner = (b.result === 'red') ? b.red : b.blue;
                    const loser = (b.result === 'red') ? b.blue : b.red;
                    state.vp[winner.team] += 1;
                    if (loser.type === 'キング') state.life[loser.team] = Math.max(0, state.life[loser.team] - 1);
                    const sp = findEmptyRespawnCell(loser.team);
                    removePieceFromCell(loser.id);
                    if (sp) movePieceTo(loser.id, sp.x, sp.y); else loser.alive = false;
                } else {
                    for (const side of [b.red, b.blue]) {
                        const sp = findEmptyRespawnCell(side.team);
                        removePieceFromCell(side.id);
                        if (sp) movePieceTo(side.id, sp.x, sp.y); else side.alive = false;
                    }
                }
            }
            battleModal.classList.remove('show');
            endTurn();
        });

        /* =========================
           ターン終了 / 勝利判定 / リザルト
        ========================= */
        function endTurn() {
            // 次チームへ
            state.phase += 1;
            state.team = (state.team === 'red') ? 'blue' : 'red';

            // 赤→青の切替ではターン据え置き、青→赤へ戻る時に+1
            if (state.team === 'red') state.turn += 1;

            // 矢印クリア
            state.arrows = [];

            // 各ピースのフラグをリセット
            for (const p of Object.values(state.pieces)) { if (!p.alive) continue; p.moved = false; p.plan = null; }

            // 勝利判定
            const winner = checkWin();
            renderAll();
            if (winner) { showResult(winner); }
        }

        function checkWin() {
            if (state.life.red <= 0 && state.life.blue <= 0) return 'draw';
            if (state.life.red <= 0) return 'blue';
            if (state.life.blue <= 0) return 'red';
            if (state.turn > state.turnLimit) {
                if (state.life.red !== state.life.blue) return state.life.red > state.life.blue ? 'red' : 'blue';
                if (state.vp.red !== state.vp.blue) return state.vp.red > state.vp.blue ? 'red' : 'blue';
                return 'draw';
            }
            return null;
        }

        function showResult(winner) {
            const modal = document.getElementById('resultModal');
            const title = document.getElementById('winnerText');
            title.textContent = winner === 'draw' ? '引き分け！' : (winner === 'red' ? '赤の勝利！' : '青の勝利！');
            const isRed = winner === 'red';
            document.getElementById('resultPanel').style.background = winner === 'draw' ? '#fff' : (isRed ? 'var(--respawn-r)' : 'var(--respawn-b)');
            title.style.background = winner === 'draw' ? '#eee' : (isRed ? 'var(--red)' : 'var(--blue)');
            title.style.color = winner === 'draw' ? '#333' : (isRed ? 'var(--red-text)' : 'var(--blue-text)');
            document.getElementById('resTurns').textContent = state.turn;
            document.getElementById('resLifeR').textContent = state.life.red;
            document.getElementById('resLifeB').textContent = state.life.blue;
            document.getElementById('resVpR').textContent = state.vp.red;
            document.getElementById('resVpB').textContent = state.vp.blue;
            modal.classList.add('show');
        }

        document.getElementById('btnCloseResult').addEventListener('click', () => {
            document.getElementById('resultModal').classList.remove('show');
        });

        /* =========================
           UI: 設定 / 開始 / 移動完了 / Undo / テンプレ/ルール説明
        ========================= */
        //設定画面
        // 左メニュー自動生成
        const menu = document.getElementById("settingsMenu");
        const sections = document.querySelectorAll(".settings-section");

        // セクションごとにメニューを追加
        sections.forEach((section, index) => {
            const li = document.createElement("li");
            li.textContent = section.dataset.title || section.id; // data-titleを優先
            li.dataset.target = section.id;
            if (index === 0) {
                li.classList.add("active");
                section.classList.add("active");
            }
            menu.appendChild(li);
        });

        // クリックで切り替え
        menu.addEventListener("click", (e) => {
            if (e.target.tagName === "LI") {
                // 左メニュー切替
                menu.querySelectorAll("li").forEach(li => li.classList.remove("active"));
                e.target.classList.add("active");

                // 右セクション切替
                sections.forEach(sec => sec.classList.remove("active"));
                document.getElementById(e.target.dataset.target).classList.add("active");
            }
        });

        // 設定画面の右上の×印でモーダルを閉じる処理
        // ×ボタンで閉じる
        document.getElementById("closeSettings").addEventListener("click", () => {
            document.getElementById("settingsModal").classList.remove('show');
        });

        document.getElementById('btnSettings').addEventListener('click', () => {
            document.getElementById('inpSize').value = state.size;
            document.getElementById('inpTurnLimit').value = state.turnLimit;
            document.getElementById('inpLifeRed').value = state.life.red;
            document.getElementById('inpLifeBlue').value = state.life.blue;
            document.getElementById('mvPawn').value = state.moveCost['ポーン'];
            document.getElementById('mvKnight').value = state.moveCost['ナイト'];
            document.getElementById('mvBishop').value = state.moveCost['ビショップ'];
            document.getElementById('mvRook').value = state.moveCost['ルーク'];
            document.getElementById('mvQueen').value = state.moveCost['クイーン'];
            document.getElementById('mvKing').value = state.moveCost['キング'];
            // kingのアタックダメージ
            document.getElementById('kingAttackDamage').value = state.kingAttackDamage;
            document.getElementById('inpDebug').value = state.debug ? 'on' : 'off';
            document.getElementById('settingsModal').classList.add('show');
        });

        document.getElementById('btnApplySettings').addEventListener('click', () => {
            state.size = +document.getElementById('inpSize').value;
            state.turnLimit = +document.getElementById('inpTurnLimit').value;
            state.life.red = +document.getElementById('inpLifeRed').value;
            state.life.blue = +document.getElementById('inpLifeBlue').value;
            state.moveCost['ポーン'] = +document.getElementById('mvPawn').value;
            state.moveCost['ナイト'] = +document.getElementById('mvKnight').value;
            state.moveCost['ビショップ'] = +document.getElementById('mvBishop').value;
            state.moveCost['ルーク'] = +document.getElementById('mvRook').value;
            state.moveCost['クイーン'] = +document.getElementById('mvQueen').value;
            state.moveCost['キング'] = +document.getElementById('mvKing').value;
            state.kingAttackDamage = +document.getElementById('kingAttackDamage').value;
            state.debug = document.getElementById('inpDebug').value === 'on';

            //resetBoard(state.size);  //これを有効にすると適用した後にコマがリセットされる
            state.phase = 0; state.turn = 0; state.team = 'red';
            state.vp = { red: 0, blue: 0 };
            state.history = [];
            document.getElementById('settingsModal').classList.remove('show');
            renderAll();
        });

        document.getElementById('btnStart').addEventListener('click', () => startGame());
        document.getElementById('btnMoveDone').addEventListener('click', () => commitMoves());
        document.getElementById('btnUndo').addEventListener('click', () => {
            if (undoOnePhase()) { renderAll(); }
        });

        /* テンプレート機構（内容は後で拡張可能） */
        const templates = {
            reset: {
                size: 7,
                turnLimit: 5,
                life: { red: 5, blue: 5 },
                kingAttackDamage: 1,
                debug: false,
                moveCost: { 'ポーン': 3, 'ナイト': 3, 'ビショップ': 4, 'ルーク': 4, 'クイーン': 5, 'キング': 3 },
                cells: [
                ],
                pieces: [
                ]
            },
            vs6: {
                size: 9,
                turnLimit: 5,
                life: { red: 5, blue: 5 },
                kingAttackDamage: 1,
                debug: false,
                moveCost: { 'ポーン': 3, 'ナイト': 3, 'ビショップ': 4, 'ルーク': 4, 'クイーン': 5, 'キング': 3 },

                cells: [
                    { x: 0, y: 1, terrain: 'respawn-red' },
                    { x: 0, y: 2, terrain: 'respawn-red' },
                    { x: 0, y: 3, terrain: 'respawn-red' },
                    { x: 0, y: 4, terrain: 'respawn-red' },
                    { x: 0, y: 5, terrain: 'respawn-red' },
                    { x: 0, y: 6, terrain: 'respawn-red' },
                    { x: 8, y: 2, terrain: 'respawn-blue' },
                    { x: 8, y: 3, terrain: 'respawn-blue' },
                    { x: 8, y: 4, terrain: 'respawn-blue' },
                    { x: 8, y: 5, terrain: 'respawn-blue' },
                    { x: 8, y: 6, terrain: 'respawn-blue' },
                    { x: 8, y: 7, terrain: 'respawn-blue' },
                    { x: 4, y: 1, terrain: 'abyss' },
                    { x: 4, y: 2, terrain: 'abyss' },
                    { x: 4, y: 6, terrain: 'abyss' },
                    { x: 4, y: 7, terrain: 'abyss' }
                ],
                pieces: [
                    { x: 1, y: 1, team: 'red', type: 'クイーン', name: 'Rクイーン' },
                    { x: 1, y: 2, team: 'red', type: 'ビショップ', name: 'Rビショップ' },
                    { x: 1, y: 3, team: 'red', type: 'キング', name: 'Rキング' },
                    { x: 1, y: 4, team: 'red', type: 'ポーン', name: 'Rポーン' },
                    { x: 1, y: 5, team: 'red', type: 'ナイト', name: 'Rナイト' },
                    { x: 1, y: 6, team: 'red', type: 'ルーク', name: 'Rルーク' },
                    { x: 7, y: 7, team: 'blue', type: 'クイーン', name: 'Bクイーン' },
                    { x: 7, y: 6, team: 'blue', type: 'ビショップ', name: 'Bビショップ' },
                    { x: 7, y: 5, team: 'blue', type: 'キング', name: 'Bキング' },
                    { x: 7, y: 4, team: 'blue', type: 'ポーン', name: 'Bポーン' },
                    { x: 7, y: 3, team: 'blue', type: 'ナイト', name: 'Bナイト' },
                    { x: 7, y: 2, team: 'blue', type: 'ルーク', name: 'Bルーク' }
                ]
            },
            vs4: {
                size: 7,
                turnLimit: 5,
                life: { red: 5, blue: 5 },
                kingAttackDamage: 1,
                debug: false,
                moveCost: { 'ポーン': 3, 'ナイト': 3, 'ビショップ': 3, 'ルーク': 3, 'クイーン': 3, 'キング': 3 },

                cells: [
                    { x: 1, y: 3, terrain: 'respawn-red' },
                    { x: 0, y: 2, terrain: 'respawn-red' },
                    { x: 0, y: 3, terrain: 'respawn-red' },
                    { x: 0, y: 4, terrain: 'respawn-red' },
                    { x: 5, y: 3, terrain: 'respawn-blue' },
                    { x: 6, y: 2, terrain: 'respawn-blue' },
                    { x: 6, y: 3, terrain: 'respawn-blue' },
                    { x: 6, y: 4, terrain: 'respawn-blue' },
                    { x: 3, y: 3, terrain: 'abyss' }
                ],
                pieces: [
                    { x: 1, y: 3, team: 'red', type: 'ビショップ', name: 'Rビショップ' },
                    { x: 0, y: 4, team: 'red', type: 'クイーン', name: 'Rクイーン' },
                    { x: 0, y: 3, team: 'red', type: 'キング', name: 'Rキング' },
                    { x: 0, y: 2, team: 'red', type: 'ルーク', name: 'Rルーク' },
                    { x: 5, y: 3, team: 'blue', type: 'ビショップ', name: 'Bビショップ' },
                    { x: 6, y: 2, team: 'blue', type: 'クイーン', name: 'Bクイーン' },
                    { x: 6, y: 3, team: 'blue', type: 'キング', name: 'Bキング' },
                    { x: 6, y: 4, team: 'blue', type: 'ルーク', name: 'Bルーク' }
                ]
            },
            vs3d: {
                size: 5,
                turnLimit: 5,
                life: { red: 15, blue: 15 },
                kingAttackDamage: 2,
                debug: false,
                moveCost: { 'ポーン': 3, 'ナイト': 3, 'ビショップ': 3, 'ルーク': 3, 'クイーン': 3, 'キング': 3 },

                cells: [
                    { x: 0, y: 1, terrain: 'respawn-red' },
                    { x: 0, y: 2, terrain: 'respawn-red' },
                    { x: 0, y: 3, terrain: 'respawn-red' },
                    { x: 4, y: 1, terrain: 'respawn-blue' },
                    { x: 4, y: 2, terrain: 'respawn-blue' },
                    { x: 4, y: 3, terrain: 'respawn-blue' },
                    { x: 0, y: 0, terrain: 'abyss' },
                    { x: 1, y: 0, terrain: 'abyss' },
                    { x: 2, y: 0, terrain: 'abyss' },
                    { x: 3, y: 0, terrain: 'abyss' },
                    { x: 4, y: 0, terrain: 'abyss' },
                    { x: 0, y: 4, terrain: 'abyss' },
                    { x: 1, y: 4, terrain: 'abyss' },
                    { x: 2, y: 4, terrain: 'abyss' },
                    { x: 3, y: 4, terrain: 'abyss' },
                    { x: 4, y: 4, terrain: 'abyss' }
                ],
                pieces: [
                    { x: 0, y: 1, team: 'red', type: 'キング', name: 'Rキング1' },
                    { x: 0, y: 2, team: 'red', type: 'キング', name: 'Rキング2' },
                    { x: 0, y: 3, team: 'red', type: 'キング', name: 'Rキング3' },
                    { x: 2, y: 3, team: 'blue', type: 'キング', name: 'Bキング1' },
                    { x: 2, y: 2, team: 'blue', type: 'キング', name: 'Bキング2' },
                    { x: 2, y: 1, team: 'blue', type: 'キング', name: 'Bキング3' }
                ]
            },
            debug1: {
                size: 5,
                turnLimit: 5,
                life: { red: 5, blue: 5 },
                kingAttackDamage: 1,
                debug: true,
                moveCost: { 'ポーン': 3, 'ナイト': 3, 'ビショップ': 3, 'ルーク': 3, 'クイーン': 3, 'キング': 3 },

                cells: [
                    { x: 0, y: 4, terrain: 'respawn-red' },
                    { x: 1, y: 4, terrain: 'respawn-red' },
                    { x: 2, y: 4, terrain: 'respawn-red' },
                    { x: 3, y: 4, terrain: 'respawn-red' },
                    { x: 4, y: 4, terrain: 'respawn-red' },
                    { x: 0, y: 0, terrain: 'respawn-blue' },
                    { x: 1, y: 0, terrain: 'respawn-blue' },
                    { x: 2, y: 0, terrain: 'respawn-blue' },
                    { x: 3, y: 0, terrain: 'respawn-blue' },
                    { x: 4, y: 0, terrain: 'respawn-blue' }
                ],
                pieces: [
                    { x: 0, y: 3, team: 'red', type: 'ポーン', name: 'RP1' },
                    { x: 1, y: 3, team: 'red', type: 'ポーン', name: 'RP2' },
                    { x: 2, y: 3, team: 'red', type: 'ポーン', name: 'RP3' },
                    { x: 3, y: 3, team: 'red', type: 'ポーン', name: 'RP4' },
                    { x: 4, y: 3, team: 'red', type: 'ポーン', name: 'RP5' },
                    { x: 0, y: 1, team: 'blue', type: 'ポーン', name: 'BP1' },
                    { x: 1, y: 1, team: 'blue', type: 'ポーン', name: 'BP2' },
                    { x: 2, y: 1, team: 'blue', type: 'ポーン', name: 'BP3' },
                    { x: 3, y: 1, team: 'blue', type: 'ポーン', name: 'BP4' },
                    { x: 4, y: 1, team: 'blue', type: 'ポーン', name: 'BP5' }
                ]
            }
        };

        document.getElementById('btnApplyTemplate').addEventListener('click', () => {
            const key = document.getElementById('inpTemplate').value;
            if (key === 'none') return;
            const t = templates[key]; if (!t) return;
            // ライフ
            if (t.life) {
                state.life.red = t.life.red;
                state.life.blue = t.life.blue;
                document.getElementById('inpLifeRed').value = t.life.red;
                document.getElementById('inpLifeBlue').value = t.life.blue;
            }

            // ターン数
            if ('turnLimit' in t) {
                state.turnLimit = t.turnLimit;
                document.getElementById('inpTurnLimit').value = t.turnLimit;
            }

            // 移動コスト
            if (t.moveCost) {
                for (const type in t.moveCost) {
                    state.moveCost[type] = t.moveCost[type];
                    // 対応する入力欄も更新
                    const idMap = {
                        'ポーン': 'mvPawn',
                        'ナイト': 'mvKnight',
                        'ビショップ': 'mvBishop',
                        'ルーク': 'mvRook',
                        'クイーン': 'mvQueen',
                        'キング': 'mvKing'
                    };
                    if (idMap[type]) document.getElementById(idMap[type]).value = t.moveCost[type];
                }
            }
            // キングアタック
            if ('kingAttackDamage' in t) {
                state.kingAttackDamage = t.kingAttackDamage;
                document.getElementById('kingAttackDamage').value = t.kingAttackDamage;
            }
            // デバッグモード
            if ('debug' in t) {
                state.debug = t.debug;
                document.getElementById('inpDebug').value = t.debug ? 'on' : 'off';
            }
            // リセット
            resetBoard(t.size);
            // 地形
            (t.cells || []).forEach(c => {
                const cell = cellAt(c.x, c.y);
                cell.terrain = c.terrain;
            });
            // 駒
            (t.pieces || []).forEach(p => {
                placePiece(p.team, p.type, p.name, p.x, p.y);
            });
            // UI反映 & 値もセットしておく
            state.phase = 0; state.turn = 0; state.team = 'red'; state.vp = { red: 0, blue: 0 }; state.history = [];
            document.getElementById('inpSize').value = t.size;
            renderAll();
            // 設定モーダルは開いたままにしておく（他の数値をそのまま調整可能）
        });


        //ルール説明
        const rules = {
            "基本ルール": `
        <h2>基本ルール</h2>
        <p>コマを動かして相手のリスポーンエリアやキングを狙いましょう。</p>
        <ul>
            <li>赤と青のチームが交互に行動します。</li>
            <li>各ターンでコマを移動してバトルします。</li>
            <li>どちらかのライフが0になると試合終了です。</li>
        </ul>
    `,
            "コマの移動とコスト": `
        <h2>コマの移動とコスト</h2>
        <p>コマは上下左右に <span class="keyword">コスト</span> 分だけ移動できます。</p>
        <p>移動には以下の制限があります</p>
        <ol>
            <li>障害物がある場所には移動できません。</li>
            <li>自チームの駒と同じ場所には移動できません。</li>
            <li>味方の予定移動先と同じ場所には移動できません。</li>
        </ol>
    `,
            "コマの移動方法": `
        <h2>コマの移動方法</h2>
        <ol>
            <li>動かしたいコマをクリックする。</li>
            <li>黄色で表示された範囲内から移動したい場所へクリック。</li>
            <li>全てのコマの移動場所を指定できたら、<br>【コマの移動を決定する】をクリックすることで移動を開始します。</li>
        </ol>
        <p>移動場所を後から変更したい場合はそのコマを再度クリックしてください。</p>
    `,
            "リスポーンエリア": `
        <h2>リスポーンエリア</h2>
        <p>バトルに<span class="lose">敗北</span>したり、アタックに成功したときに</p>
        <p>飛ばされる(ワープされる)マスを<span class="keyword">リスポーンエリア</span>と言います。</p>
        <ul>
        <li>相手のリスポーンエリアにコマを置くことを<span class="keyword">アタック</span>と言います。</li>
        <li>アタックに成功すると、相手のライフが<span class="damage">1減ります</span>。</li>
        <li>アタックをしたコマは、自チームのリスポーンエリアに飛ばされます。</li>
        <li>リスポーンエリアにおけるバトルは発生しません。</li>
        </ul>
    `,
            "バトル": `
        <h2>バトル</h2>
        <p>敵と同じマスに移動するとバトルとなります。</p>
        <ul>
            <li><span class="win">勝利</span> → 相手をリスポーン地点に飛ばす。勝利ptが1増える。</li>
            <li><span class="lose">敗北</span> → 自分がリスポーン地点に飛ばされる</li>
        </ul>
    `,
            "キング": `
        <h2>キング</h2>
        <ul>
        <li><b>キングがバトルに<span class="lose">敗北</span>した場合</b>、そのチームのライフが <span class="damage">1減ります</span>。</li>
        <li>キングがバトルに<span class="win">勝利</span>しても特別なことは起こりません。</li>
        <li>キングアタックの設定が有効(2以上)の場合、<br>キングが敵のリスポーンに入ると、設定された分の<br>大きなダメージを相手ライフに与えます。</li>
        <ul>
    `,
            "勝利条件": `
        <h2>勝利条件</h2>
        <p>以下のいずれかで勝利となります</p>
        <ul>
            <li>相手のライフを 0 にする</li>
            <li>ターン終了時に相手より多くのライフを持つ</li>
            <li>ターン終了時にライフが同じ場合 相手より多くの勝利Ptを持つ</li>
        </ul>
    `,
            "コマの種類": `
        <h2>コマの種類</h2>
        <p>ポーン、ナイト、ビショップ、ルーク、クイーン、キングの6種類のコマがあります。</p>
        <p>設定からコマごとに移動コストを設定することが可能です。</p>
        <p><b>キングがバトルに<span class="lose">敗北</span>した場合</b>、そのチームのライフが <span class="damage">1減ります</span>。</p>
    `,
            "移動プランナー": `
        <h2>移動プランナー</h2>
        <ul>
        <li>移動プランナーを使えば、動かすコマの指定を対戦相手や<br>ゲームマスターに素早く伝えることができます。</li>
        <li>コマの移動先を決めた後に移動プランナー生成を押すことで、<br>プランナーがコピーされます。</li>
        <li>プランナーを下方にあるテキストエリアに張り付けた後、プランナーを適用を押すことでコマの移動先が表示されるようになります。</li>
        </ul>
    `
        };

        const btnRule = document.getElementById('btnRule');
        const ruleModal = document.getElementById('ruleModal');
        const closeRule = document.getElementById('closeRule');
        const ruleList = document.getElementById('ruleList');
        const ruleBody = document.getElementById('ruleBody');

        // モーダル表示
        btnRule.addEventListener('click', () => {
            ruleModal.classList.add('show');
        });

        // モーダル閉じる
        closeRule.addEventListener('click', () => {
            ruleModal.classList.remove('show');
        });

        // 目次生成
        for (const [title, content] of Object.entries(rules)) {
            const li = document.createElement('li');
            li.textContent = title;
            li.addEventListener('click', () => {
                // 本文を切り替え
                ruleBody.innerHTML = content;

                // 他の active を外す
                document.querySelectorAll('#ruleModal .toc li').forEach(x => x.classList.remove('active'));

                // この li に active を付ける
                li.classList.add('active');
            });
            ruleList.appendChild(li);
        }

        // 初期表示は最初のルール
        const firstKey = Object.keys(rules)[0];
        if (firstKey) {
            ruleBody.innerHTML = rules[firstKey];
            // 最初の li を active にする
            ruleList.firstChild.classList.add('active');
        }
        /* =========================
           初期化
        ========================= */
        resetBoard(8);
        renderAll();
    </script>
</body>

</html>
